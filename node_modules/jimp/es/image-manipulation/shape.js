function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-disable no-labels */
import Resize from '../modules/resize';
import Resize2 from '../modules/resize2';
import { isNodePattern, throwError } from '../utils/error-checking';
import * as constants from '../constants';

function rotate90degrees(bitmap, dstBuffer, clockwise) {
  var dstOffsetStep = clockwise ? -4 : 4;
  var dstOffset = clockwise ? dstBuffer.length - 4 : 0;
  var tmp;
  var x;
  var y;
  var srcOffset;

  for (x = 0; x < bitmap.width; x++) {
    for (y = bitmap.height - 1; y >= 0; y--) {
      srcOffset = bitmap.width * y + x << 2;
      tmp = bitmap.data.readUInt32BE(srcOffset, true);
      dstBuffer.writeUInt32BE(tmp, dstOffset, true);
      dstOffset += dstOffsetStep;
    }
  }
}
/**
 * Rotates an image clockwise by a number of degrees rounded to the nearest 90 degrees. NB: 'this' must be a Jimp object.
 * @param {number} deg the number of degrees to rotate the image by
 */


function simpleRotate(deg) {
  var steps = Math.round(deg / 90) % 4;
  steps += steps < 0 ? 4 : 0;
  if (steps === 0) return;
  var srcBuffer = this.bitmap.data;
  var len = srcBuffer.length;
  var dstBuffer = Buffer.allocUnsafe(len);
  var tmp;

  if (steps === 2) {
    // Upside-down
    for (var srcOffset = 0; srcOffset < len; srcOffset += 4) {
      tmp = srcBuffer.readUInt32BE(srcOffset, true);
      dstBuffer.writeUInt32BE(tmp, len - srcOffset - 4, true);
    }
  } else {
    // Clockwise or counter-clockwise rotation by 90 degree
    rotate90degrees(this.bitmap, dstBuffer, steps === 1);
    tmp = this.bitmap.width;
    this.bitmap.width = this.bitmap.height;
    this.bitmap.height = tmp;
  }

  this.bitmap.data = dstBuffer;
}
/**
 * Rotates an image clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.
 * @param {number} deg the number of degrees to rotate the image by
 * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed
 */


function advancedRotate(deg, mode) {
  deg %= 360;
  var rad = deg * Math.PI / 180;
  var cosine = Math.cos(rad);
  var sine = Math.sin(rad); // the final width and height will change if resize == true

  var w = this.bitmap.width;
  var h = this.bitmap.height;

  if (mode === true || typeof mode === 'string') {
    // resize the image to it maximum dimension and blit the existing image
    // onto the center so that when it is rotated the image is kept in bounds
    // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle
    // Plus 1 border pixel to ensure to show all rotated result for some cases.
    w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;
    h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1; // Ensure destination to have even size to a better result.

    if (w % 2 !== 0) {
      w++;
    }

    if (h % 2 !== 0) {
      h++;
    }

    var c = this.cloneQuiet();
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
      this.bitmap.data.writeUInt32BE(this._background, idx);
    });
    var max = Math.max(w, h, this.bitmap.width, this.bitmap.height);
    this.resize(max, max, mode);
    this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);
  }

  var bW = this.bitmap.width;
  var bH = this.bitmap.height;
  var dstBuffer = Buffer.alloc(this.bitmap.data.length);

  function createTranslationFunction(deltaX, deltaY) {
    return function (x, y) {
      return {
        x: x + deltaX,
        y: y + deltaY
      };
    };
  }

  var translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));
  var translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);

  for (var y = 1; y <= bH; y++) {
    for (var x = 1; x <= bW; x++) {
      var cartesian = translate2Cartesian(x, y);
      var source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);
      var dstIdx = bW * (y - 1) + x - 1 << 2;

      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
        var srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;
        var pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);
        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
      } else {
        // reset off-image pixels
        dstBuffer.writeUInt32BE(this._background, dstIdx);
      }
    }
  }

  this.bitmap.data = dstBuffer;

  if (mode === true || typeof mode === 'string') {
    // now crop the image to the final size
    var _x2 = bW / 2 - w / 2;

    var _y2 = bH / 2 - h / 2;

    this.crop(_x2, _y2, w, h);
  }
}
/**
 * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.
 * @param {number} deg the number of degrees to rotate the image by
 * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */


export function rotate(deg, mode, cb) {
  // enable overloading
  if (typeof mode === 'undefined' || mode === null) {
    // e.g. image.resize(120);
    // e.g. image.resize(120, null, cb);
    // e.g. image.resize(120, undefined, cb);
    mode = true;
  }

  if (typeof mode === 'function' && typeof cb === 'undefined') {
    // e.g. image.resize(120, cb);
    cb = mode;
    mode = true;
  }

  if (typeof deg !== 'number') {
    return throwError.call(this, 'deg must be a number', cb);
  }

  if (typeof mode !== 'boolean' && typeof mode !== 'string') {
    return throwError.call(this, 'mode must be a boolean or a string', cb);
  }

  if (deg % 90 === 0 && Boolean(mode) === false) {
    simpleRotate.call(this, deg, cb);
  } else {
    advancedRotate.call(this, deg, mode, cb);
  }

  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }

  return this;
}
/**
 * Flip the image horizontally
 * @param {boolean} horizontal a Boolean, if true the image will be flipped horizontally
 * @param {boolean} vertical a Boolean, if true the image will be flipped vertically
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

function flipFn(horizontal, vertical, cb) {
  if (typeof horizontal !== 'boolean' || typeof vertical !== 'boolean') return throwError.call(this, 'horizontal and vertical must be Booleans', cb);

  if (horizontal && vertical) {
    // shortcut
    return this.rotate(180, true, cb);
  }

  var bitmap = Buffer.alloc(this.bitmap.data.length);
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
    var _x = horizontal ? this.bitmap.width - 1 - x : x;

    var _y = vertical ? this.bitmap.height - 1 - y : y;

    var _idx = this.bitmap.width * _y + _x << 2;

    var data = this.bitmap.data.readUInt32BE(idx);
    bitmap.writeUInt32BE(data, _idx);
  });
  this.bitmap.data = Buffer.from(bitmap);

  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }

  return this;
}

export var flip = flipFn;
export var mirror = flipFn;
/**
 * Resizes the image to a set width and height using a 2-pass bilinear algorithm
 * @param {number} w the width to resize the image to (or Jimp.AUTO)
 * @param {number} h the height to resize the image to (or Jimp.AUTO)
 * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

export function resize(w, h, mode, cb) {
  if (typeof w !== 'number' || typeof h !== 'number') {
    return throwError.call(this, 'w and h must be numbers', cb);
  }

  if (typeof mode === 'function' && typeof cb === 'undefined') {
    cb = mode;
    mode = null;
  }

  if (w === constants.AUTO && h === constants.AUTO) {
    return throwError.call(this, 'w and h cannot both be set to auto', cb);
  }

  if (w === constants.AUTO) {
    w = this.bitmap.width * (h / this.bitmap.height);
  }

  if (h === constants.AUTO) {
    h = this.bitmap.height * (w / this.bitmap.width);
  }

  if (w < 0 || h < 0) {
    return throwError.call(this, 'w and h must be positive numbers', cb);
  } // round inputs


  w = Math.round(w);
  h = Math.round(h);

  if (typeof Resize2[mode] === 'function') {
    var dst = {
      data: Buffer.alloc(w * h * 4),
      width: w,
      height: h
    };
    Resize2[mode](this.bitmap, dst);
    this.bitmap = dst;
  } else {
    var image = this;

    var _resize = new Resize(this.bitmap.width, this.bitmap.height, w, h, true, true, function (buffer) {
      image.bitmap.data = Buffer.from(buffer);
      image.bitmap.width = w;
      image.bitmap.height = h;
    });

    _resize.resize(this.bitmap.data);
  }

  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }

  return this;
}
/**
 * Scale the image so the given width and height keeping the aspect ratio. Some parts of the image may be clipped.
 * @param {number} w the width to resize the image to
 * @param {number} h the height to resize the image to
 * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment
 * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

export function cover(w, h, alignBits, mode, cb) {
  if (typeof w !== 'number' || typeof h !== 'number') {
    return throwError.call(this, 'w and h must be numbers', cb);
  }

  if (alignBits && typeof alignBits === 'function' && typeof cb === 'undefined') {
    cb = alignBits;
    alignBits = null;
    mode = null;
  } else if (typeof mode === 'function' && typeof cb === 'undefined') {
    cb = mode;
    mode = null;
  }

  alignBits = alignBits || constants.HORIZONTAL_ALIGN_CENTER | constants.VERTICAL_ALIGN_MIDDLE;
  var hbits = alignBits & (1 << 3) - 1;
  var vbits = alignBits >> 3; // check if more flags than one is in the bit sets

  if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) return throwError.call(this, 'only use one flag per alignment direction', cb);
  var alignH = hbits >> 1; // 0, 1, 2

  var alignV = vbits >> 1; // 0, 1, 2

  var f = w / h > this.bitmap.width / this.bitmap.height ? w / this.bitmap.width : h / this.bitmap.height;
  this.scale(f, mode);
  this.crop((this.bitmap.width - w) / 2 * alignH, (this.bitmap.height - h) / 2 * alignV, w, h);

  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }

  return this;
}
/**
 * Scale the image to the given width and height keeping the aspect ratio. Some parts of the image may be letter boxed.
 * @param {number} w the width to resize the image to
 * @param {number} h the height to resize the image to
 * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment
 * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

export function contain(w, h, alignBits, mode, cb) {
  if (typeof w !== 'number' || typeof h !== 'number') {
    return throwError.call(this, 'w and h must be numbers', cb);
  } // permit any sort of optional parameters combination


  if (typeof alignBits === 'string') {
    if (typeof mode === 'function' && typeof cb === 'undefined') cb = mode;
    mode = alignBits;
    alignBits = null;
  }

  if (typeof alignBits === 'function') {
    if (typeof cb === 'undefined') cb = alignBits;
    mode = null;
    alignBits = null;
  }

  if (typeof mode === 'function' && typeof cb === 'undefined') {
    cb = mode;
    mode = null;
  }

  alignBits = alignBits || constants.HORIZONTAL_ALIGN_CENTER | constants.VERTICAL_ALIGN_MIDDLE;
  var hbits = alignBits & (1 << 3) - 1;
  var vbits = alignBits >> 3; // check if more flags than one is in the bit sets

  if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {
    return throwError.call(this, 'only use one flag per alignment direction', cb);
  }

  var alignH = hbits >> 1; // 0, 1, 2

  var alignV = vbits >> 1; // 0, 1, 2

  var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
  var c = this.cloneQuiet().scale(f, mode);
  this.resize(w, h, mode);
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
    this.bitmap.data.writeUInt32BE(this._background, idx);
  });
  this.blit(c, (this.bitmap.width - c.bitmap.width) / 2 * alignH, (this.bitmap.height - c.bitmap.height) / 2 * alignV);

  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }

  return this;
}
/**
 * Uniformly scales the image by a factor.
 * @param {number} f the factor to scale the image by
 * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

export function scale(f, mode, cb) {
  if (typeof f !== 'number') {
    return throwError.call(this, 'f must be a number', cb);
  }

  if (f < 0) {
    return throwError.call(this, 'f must be a positive number', cb);
  }

  if (typeof mode === 'function' && typeof cb === 'undefined') {
    cb = mode;
    mode = null;
  }

  var w = this.bitmap.width * f;
  var h = this.bitmap.height * f;
  this.resize(w, h, mode);

  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }

  return this;
}
/**
 * Scale the image to the largest size that fits inside the rectangle that has the given width and height.
 * @param {number} w the width to resize the image to
 * @param {number} h the height to resize the image to
 * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

export function scaleToFit(w, h, mode, cb) {
  if (typeof w !== 'number' || typeof h !== 'number') {
    return throwError.call(this, 'w and h must be numbers', cb);
  }

  if (typeof mode === 'function' && typeof cb === 'undefined') {
    cb = mode;
    mode = null;
  }

  var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
  this.scale(f, mode);

  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }

  return this;
}
/**
 * Displaces the image based on the provided displacement map
 * @param {object} map the source Jimp instance
 * @param {number} offset the maximum displacement value
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

export function displace(map, offset, cb) {
  if (_typeof(map) !== 'object' || map.constructor !== this.constructor) {
    return throwError.call(this, 'The source must be a Jimp image', cb);
  }

  if (typeof offset !== 'number') {
    return throwError.call(this, 'factor must be a number', cb);
  }

  var source = this.cloneQuiet();
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
    var displacement = map.bitmap.data[idx] / 256 * offset;
    displacement = Math.round(displacement);
    var ids = this.getPixelIndex(x + displacement, y);
    this.bitmap.data[ids] = source.bitmap.data[idx];
    this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];
    this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
  });

  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }

  return this;
}
/**
 * Autocrop same color borders from this image
 * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)
 * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)
 * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)
 * @returns {Jimp} this for chaining of methods
 */

export function autocrop() {
  var w = this.bitmap.width;
  var h = this.bitmap.height;
  var minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image

  var cb; // callback

  var tolerance = 0.0002; // percent of color difference tolerance (default value)

  var cropOnlyFrames = true; // flag to force cropping only if the image has a real "frame"
  // i.e. all 4 sides have some border (default value)
  // parse arguments

  for (var a = 0, len = arguments.length; a < len; a++) {
    if (typeof (a < 0 || arguments.length <= a ? undefined : arguments[a]) === 'number') {
      // tolerance value passed
      tolerance = a < 0 || arguments.length <= a ? undefined : arguments[a];
    }

    if (typeof (a < 0 || arguments.length <= a ? undefined : arguments[a]) === 'boolean') {
      // cropOnlyFrames value passed
      cropOnlyFrames = a < 0 || arguments.length <= a ? undefined : arguments[a];
    }

    if (typeof (a < 0 || arguments.length <= a ? undefined : arguments[a]) === 'function') {
      // callback value passed
      cb = a < 0 || arguments.length <= a ? undefined : arguments[a];
    }
  }
  /**
   * All borders must be of the same color as the top left pixel, to be cropped.
   * It should be possible to crop borders each with a different color,
   * but since there are many ways for corners to intersect, it would
   * introduce unnecessary complexity to the algorithm.
   */
  // scan each side for same color borders


  var colorTarget = this.getPixelColor(0, 0); // top left pixel color is the target color

  var rgba1 = this.constructor.intToRGBA(colorTarget); // for north and east sides

  var northPixelsToCrop = 0;
  var eastPixelsToCrop = 0;
  var southPixelsToCrop = 0;
  var westPixelsToCrop = 0; // north side (scan rows from north to south)

  north: for (var y = 0; y < h - minPixelsPerSide; y++) {
    for (var x = 0; x < w; x++) {
      var colorXY = this.getPixelColor(x, y);
      var rgba2 = this.constructor.intToRGBA(colorXY);

      if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
        // this pixel is too distant from the first one: abort this side scan
        break north;
      }
    } // this row contains all pixels with the same color: increment this side pixels to crop


    northPixelsToCrop++;
  } // east side (scan columns from east to west)


  east: for (var _x3 = 0; _x3 < w - minPixelsPerSide; _x3++) {
    for (var _y3 = 0 + northPixelsToCrop; _y3 < h; _y3++) {
      var _colorXY = this.getPixelColor(_x3, _y3);

      var _rgba = this.constructor.intToRGBA(_colorXY);

      if (this.constructor.colorDiff(rgba1, _rgba) > tolerance) {
        // this pixel is too distant from the first one: abort this side scan
        break east;
      }
    } // this column contains all pixels with the same color: increment this side pixels to crop


    eastPixelsToCrop++;
  } // south side (scan rows from south to north)


  south: for (var _y4 = h - 1; _y4 >= northPixelsToCrop + minPixelsPerSide; _y4--) {
    for (var _x4 = w - eastPixelsToCrop - 1; _x4 >= 0; _x4--) {
      var _colorXY2 = this.getPixelColor(_x4, _y4);

      var _rgba2 = this.constructor.intToRGBA(_colorXY2);

      if (this.constructor.colorDiff(rgba1, _rgba2) > tolerance) {
        // this pixel is too distant from the first one: abort this side scan
        break south;
      }
    } // this row contains all pixels with the same color: increment this side pixels to crop


    southPixelsToCrop++;
  } // west side (scan columns from west to east)


  west: for (var _x5 = w - 1; _x5 >= 0 + eastPixelsToCrop + minPixelsPerSide; _x5--) {
    for (var _y5 = h - 1; _y5 >= 0 + northPixelsToCrop; _y5--) {
      var _colorXY3 = this.getPixelColor(_x5, _y5);

      var _rgba3 = this.constructor.intToRGBA(_colorXY3);

      if (this.constructor.colorDiff(rgba1, _rgba3) > tolerance) {
        // this pixel is too distant from the first one: abort this side scan
        break west;
      }
    } // this column contains all pixels with the same color: increment this side pixels to crop


    westPixelsToCrop++;
  } // safety checks


  var widthOfPixelsToCrop = w - (westPixelsToCrop + eastPixelsToCrop); // widthOfPixelsToCrop >= 0 ? widthOfPixelsToCrop : 0;

  var heightOfPixelsToCrop = h - (southPixelsToCrop + northPixelsToCrop); // heightOfPixelsToCrop >= 0 ? heightOfPixelsToCrop : 0;
  // decide if a crop is needed

  var doCrop = false;

  if (cropOnlyFrames) {
    // crop image if all sides should be cropped
    doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;
  } else {
    // crop image if at least one side should be cropped
    doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;
  }

  if (doCrop) {
    // do the real crop
    this.crop(eastPixelsToCrop, northPixelsToCrop, widthOfPixelsToCrop, heightOfPixelsToCrop);
  }

  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }

  return this;
}
//# sourceMappingURL=shape.js.map