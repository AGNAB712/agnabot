"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseBitmap = parseBitmap;
exports.getBuffer = getBuffer;
exports.getBufferAsync = getBufferAsync;

var _fileType = _interopRequireDefault(require("file-type"));

var _pngjs = require("pngjs");

var _jpegJs = _interopRequireDefault(require("jpeg-js"));

var _bmpJs = _interopRequireDefault(require("bmp-js"));

var _utif = _interopRequireDefault(require("utif"));

var _exifParser = _interopRequireDefault(require("exif-parser"));

var _omggif = _interopRequireDefault(require("omggif"));

var constants = _interopRequireWildcard(require("../constants"));

var _errorChecking = require("./error-checking");

var MIME = _interopRequireWildcard(require("./mime"));

var _promisify = _interopRequireDefault(require("./promisify"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getMIMEFromBuffer(buffer, path) {
  var fileTypeFromBuffer = (0, _fileType.default)(buffer);

  if (fileTypeFromBuffer) {
    // If fileType returns something for buffer, then return the mime given
    return fileTypeFromBuffer.mime;
  }

  if (path) {
    // If a path is supplied, and fileType yields no results, then retry with MIME
    // Path can be either a file path or a url
    return MIME.getType(path);
  }

  return null;
} // gets image data from a GIF buffer


function getBitmapFromGIF(data) {
  var gifObj = new _omggif.default.GifReader(data);
  var gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
  gifObj.decodeAndBlitFrameRGBA(0, gifData);
  return {
    data: gifData,
    width: gifObj.width,
    height: gifObj.height
  };
}
/*
 * Automagically rotates an image based on its EXIF data (if present)
 * @param img a constants object
*/


function exifRotate(img) {
  var exif = img._exif;

  if (exif && exif.tags && exif.tags.Orientation) {
    switch (img._exif.tags.Orientation) {
      case 1:
        // Horizontal (normal)
        // do nothing
        break;

      case 2:
        // Mirror horizontal
        img.mirror(true, false);
        break;

      case 3:
        // Rotate 180
        img.rotate(180, false);
        break;

      case 4:
        // Mirror vertical
        img.mirror(false, true);
        break;

      case 5:
        // Mirror horizontal and rotate 270 CW
        img.rotate(-90, false).mirror(true, false);
        break;

      case 6:
        // Rotate 90 CW
        img.rotate(-90, false);
        break;

      case 7:
        // Mirror horizontal and rotate 90 CW
        img.rotate(90, false).mirror(true, false);
        break;

      case 8:
        // Rotate 270 CW
        img.rotate(-270, false);
        break;

      default:
        break;
    }
  }

  return img;
} // parses a bitmap from the constructor to the JIMP bitmap property


function parseBitmap(data, path, cb) {
  var _this = this;

  var mime = getMIMEFromBuffer(data, path);

  if (typeof mime !== 'string') {
    return cb(new Error('Could not find MIME for Buffer <' + path + '>'));
  }

  this._originalMime = mime.toLowerCase();

  switch (this.getMIME()) {
    case constants.MIME_PNG:
      {
        var png = new _pngjs.PNG();
        png.parse(data, function (err, data) {
          if (err) {
            return _errorChecking.throwError.call(_this, err, cb);
          }

          _this.bitmap = {
            data: Buffer.from(data.data),
            width: data.width,
            height: data.height
          };
          cb.call(_this, null, _this);
        });
        break;
      }

    case constants.MIME_JPEG:
      try {
        this.bitmap = _jpegJs.default.decode(data);

        try {
          this._exif = _exifParser.default.create(data).parse();
          exifRotate(this); // EXIF data
        } catch (err) {
          /* meh */
        }

        cb.call(this, null, this);
      } catch (err) {
        cb.call(this, err, this);
      }

      break;

    case constants.MIME_TIFF:
      {
        var ifds = _utif.default.decode(data);

        var page = ifds[0];

        _utif.default.decodeImages(data, ifds);

        var rgba = _utif.default.toRGBA8(page);

        this.bitmap = {
          data: Buffer.from(rgba),
          width: page.t256[0],
          height: page.t257[0]
        };
        cb.call(this, null, this);
        break;
      }

    case constants.MIME_BMP:
    case constants.MIME_X_MS_BMP:
      this.bitmap = _bmpJs.default.decode(data);
      cb.call(this, null, this);
      break;

    case constants.MIME_GIF:
      this.bitmap = getBitmapFromGIF(data);
      cb.call(this, null, this);
      break;

    default:
      return _errorChecking.throwError.call(this, 'Unsupported MIME type: ' + mime, cb);
  }

  return this;
}

function compositeBitmapOverBackground(Jimp, image) {
  return new Jimp(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;
}
/**
 * Converts the image to a buffer
 * @param {string} mime the mime type of the image buffer to be created
 * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
 * @returns {Jimp} this for chaining of methods
 */


function getBuffer(mime, cb) {
  if (mime === constants.AUTO) {
    // allow auto MIME detection
    mime = this.getMIME();
  }

  if (typeof mime !== 'string') {
    return _errorChecking.throwError.call(this, 'mime must be a string', cb);
  }

  if (typeof cb !== 'function') {
    return _errorChecking.throwError.call(this, 'cb must be a function', cb);
  }

  switch (mime.toLowerCase()) {
    case constants.MIME_PNG:
      {
        var png = new _pngjs.PNG({
          width: this.bitmap.width,
          height: this.bitmap.height,
          bitDepth: 8,
          deflateLevel: this._deflateLevel,
          deflateStrategy: this._deflateStrategy,
          filterType: this._filterType,
          colorType: this._rgba ? 6 : 2,
          inputHasAlpha: true
        });

        if (this._rgba) {
          png.data = Buffer.from(this.bitmap.data);
        } else {
          // when PNG doesn't support alpha
          png.data = compositeBitmapOverBackground(this.constructor, this).data;
        }

        var buffer = _pngjs.PNG.sync.write(png);

        cb.call(this, null, buffer);
        break;
      }

    case constants.MIME_JPEG:
      {
        // composite onto a new image so that the background shows through alpha channels
        var jpeg = _jpegJs.default.encode(compositeBitmapOverBackground(this.constructor, this), this._quality);

        cb.call(this, null, jpeg.data);
        break;
      }

    case constants.MIME_BMP:
    case constants.MIME_X_MS_BMP:
      {
        // composite onto a new image so that the background shows through alpha channels
        var bmp = _bmpJs.default.encode(compositeBitmapOverBackground(this.constructor, this));

        cb.call(this, null, bmp.data);
        break;
      }

    case constants.MIME_TIFF:
      {
        var c = compositeBitmapOverBackground(this.constructor, this);

        var tiff = _utif.default.encodeImage(c.data, c.width, c.height);

        cb.call(this, null, Buffer.from(tiff));
        break;
      }

    default:
      cb.call(this, 'Unsupported MIME type: ' + mime);
      break;
  }

  return this;
}

function getBufferAsync(mime) {
  return (0, _promisify.default)(getBuffer, this, mime);
}
//# sourceMappingURL=image-bitmap.js.map