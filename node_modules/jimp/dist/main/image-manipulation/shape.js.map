{"version":3,"sources":["../../../src/image-manipulation/shape.js"],"names":["simpleRotate","deg","i","Math","round","dstBuffer","Buffer","alloc","bitmap","data","length","dstOffset","x","width","y","height","srcOffset","readUInt32BE","writeUInt32BE","from","tmp","advancedRotate","mode","rad","PI","cosine","cos","sine","sin","w","h","ceil","abs","c","cloneQuiet","scanQuiet","idx","_background","max","resize","blit","bW","bH","createTranslationFunction","deltaX","deltaY","translate2Cartesian","translate2Screen","cartesian","source","dstIdx","srcIdx","pixelRGBA","crop","rotate","cb","throwError","call","Boolean","flipFn","horizontal","vertical","_x","_y","_idx","flip","mirror","constants","AUTO","Resize2","dst","image","Resize","buffer","cover","alignBits","HORIZONTAL_ALIGN_CENTER","VERTICAL_ALIGN_MIDDLE","hbits","vbits","alignH","alignV","f","scale","contain","scaleToFit","displace","map","offset","constructor","displacement","ids","getPixelIndex","autocrop","minPixelsPerSide","tolerance","cropOnlyFrames","a","len","colorTarget","getPixelColor","rgba1","intToRGBA","northPixelsToCrop","eastPixelsToCrop","southPixelsToCrop","westPixelsToCrop","north","colorXY","rgba2","colorDiff","east","south","west","widthOfPixelsToCrop","heightOfPixelsToCrop","doCrop"],"mappings":"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","sourcesContent":["/* eslint-disable no-labels */\n\nimport Resize from '../modules/resize';\nimport Resize2 from '../modules/resize2';\n\nimport { isNodePattern, throwError } from '../utils/error-checking';\nimport * as constants from '../constants';\n\n/**\n * Rotates an image clockwise by a number of degrees rounded to the nearest 90 degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n */\nfunction simpleRotate(deg) {\n    let i = Math.round(deg / 90) % 4;\n    while (i < 0) i += 4;\n\n    while (i > 0) {\n        // https://github.com/ekulabuhov/jimp/commit/9a0c7cff88292d88c32a424b11256c76f1e20e46\n        const dstBuffer = Buffer.alloc(this.bitmap.data.length);\n        let dstOffset = 0;\n\n        for (let x = this.bitmap.width - 1; x >= 0; x--) {\n            for (let y = 0; y < this.bitmap.height; y++) {\n                const srcOffset = (this.bitmap.width * y + x) << 2;\n                const data = this.bitmap.data.readUInt32BE(srcOffset);\n                dstBuffer.writeUInt32BE(data, dstOffset);\n                dstOffset += 4;\n            }\n        }\n\n        this.bitmap.data = Buffer.from(dstBuffer);\n\n        const tmp = this.bitmap.width;\n        this.bitmap.width = this.bitmap.height;\n        this.bitmap.height = tmp;\n\n        i--;\n    }\n}\n\n/**\n * Rotates an image clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n */\nfunction advancedRotate(deg, mode) {\n    deg %= 360;\n    const rad = (deg * Math.PI) / 180;\n    const cosine = Math.cos(rad);\n    const sine = Math.sin(rad);\n\n    // the final width and height will change if resize == true\n    let w = this.bitmap.width;\n    let h = this.bitmap.height;\n\n    if (mode === true || typeof mode === 'string') {\n        // resize the image to it maximum dimension and blit the existing image\n        // onto the center so that when it is rotated the image is kept in bounds\n\n        // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n        // Plus 1 border pixel to ensure to show all rotated result for some cases.\n        w =\n            Math.ceil(\n                Math.abs(this.bitmap.width * cosine) +\n                    Math.abs(this.bitmap.height * sine)\n            ) + 1;\n        h =\n            Math.ceil(\n                Math.abs(this.bitmap.width * sine) +\n                    Math.abs(this.bitmap.height * cosine)\n            ) + 1;\n        // Ensure destination to have even size to a better result.\n        if (w % 2 !== 0) {\n            w++;\n        }\n\n        if (h % 2 !== 0) {\n            h++;\n        }\n\n        const c = this.cloneQuiet();\n        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n            x,\n            y,\n            idx\n        ) {\n            this.bitmap.data.writeUInt32BE(this._background, idx);\n        });\n\n        const max = Math.max(w, h, this.bitmap.width, this.bitmap.height);\n        this.resize(max, max, mode);\n\n        this.blit(\n            c,\n            this.bitmap.width / 2 - c.bitmap.width / 2,\n            this.bitmap.height / 2 - c.bitmap.height / 2\n        );\n    }\n\n    const bW = this.bitmap.width;\n    const bH = this.bitmap.height;\n    const dstBuffer = Buffer.alloc(this.bitmap.data.length);\n\n    function createTranslationFunction(deltaX, deltaY) {\n        return function(x, y) {\n            return {\n                x: x + deltaX,\n                y: y + deltaY\n            };\n        };\n    }\n\n    const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));\n    const translate2Screen = createTranslationFunction(\n        bW / 2 + 0.5,\n        bH / 2 + 0.5\n    );\n\n    for (let y = 1; y <= bH; y++) {\n        for (let x = 1; x <= bW; x++) {\n            const cartesian = translate2Cartesian(x, y);\n            const source = translate2Screen(\n                cosine * cartesian.x - sine * cartesian.y,\n                cosine * cartesian.y + sine * cartesian.x\n            );\n            const dstIdx = (bW * (y - 1) + x - 1) << 2;\n\n            if (\n                source.x >= 0 &&\n                source.x < bW &&\n                source.y >= 0 &&\n                source.y < bH\n            ) {\n                const srcIdx = ((bW * (source.y | 0) + source.x) | 0) << 2;\n                const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n                dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n            } else {\n                // reset off-image pixels\n                dstBuffer.writeUInt32BE(this._background, dstIdx);\n            }\n        }\n    }\n    this.bitmap.data = dstBuffer;\n\n    if (mode === true || typeof mode === 'string') {\n        // now crop the image to the final size\n        const x = bW / 2 - w / 2;\n        const y = bH / 2 - h / 2;\n        this.crop(x, y, w, h);\n    }\n}\n\n/**\n * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function rotate(deg, mode, cb) {\n    // enable overloading\n    if (typeof mode === 'undefined' || mode === null) {\n        // e.g. image.resize(120);\n        // e.g. image.resize(120, null, cb);\n        // e.g. image.resize(120, undefined, cb);\n        mode = true;\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n        // e.g. image.resize(120, cb);\n        cb = mode;\n        mode = true;\n    }\n\n    if (typeof deg !== 'number') {\n        return throwError.call(this, 'deg must be a number', cb);\n    }\n\n    if (typeof mode !== 'boolean' && typeof mode !== 'string') {\n        return throwError.call(this, 'mode must be a boolean or a string', cb);\n    }\n\n    if (deg % 90 === 0 && Boolean(mode) === false) {\n        simpleRotate.call(this, deg, cb);\n    } else {\n        advancedRotate.call(this, deg, mode, cb);\n    }\n\n    if (isNodePattern(cb)) {\n        return cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Flip the image horizontally\n * @param {boolean} horizontal a Boolean, if true the image will be flipped horizontally\n * @param {boolean} vertical a Boolean, if true the image will be flipped vertically\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nfunction flipFn(horizontal, vertical, cb) {\n    if (typeof horizontal !== 'boolean' || typeof vertical !== 'boolean')\n        return throwError.call(\n            this,\n            'horizontal and vertical must be Booleans',\n            cb\n        );\n\n    const bitmap = Buffer.alloc(this.bitmap.data.length);\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n        x,\n        y,\n        idx\n    ) {\n        const _x = horizontal ? this.bitmap.width - 1 - x : x;\n        const _y = vertical ? this.bitmap.height - 1 - y : y;\n        const _idx = (this.bitmap.width * _y + _x) << 2;\n        const data = this.bitmap.data.readUInt32BE(idx);\n\n        bitmap.writeUInt32BE(data, _idx);\n    });\n\n    this.bitmap.data = Buffer.from(bitmap);\n\n    if (isNodePattern(cb)) {\n        return cb.call(this, null, this);\n    }\n\n    return this;\n}\n\nexport const flip = flipFn;\nexport const mirror = flipFn;\n\n/**\n * Resizes the image to a set width and height using a 2-pass bilinear algorithm\n * @param {number} w the width to resize the image to (or Jimp.AUTO)\n * @param {number} h the height to resize the image to (or Jimp.AUTO)\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function resize(w, h, mode, cb) {\n    if (typeof w !== 'number' || typeof h !== 'number') {\n        return throwError.call(this, 'w and h must be numbers', cb);\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n    }\n\n    if (w === constants.AUTO && h === constants.AUTO) {\n        return throwError.call(this, 'w and h cannot both be set to auto', cb);\n    }\n\n    if (w === constants.AUTO) {\n        w = this.bitmap.width * (h / this.bitmap.height);\n    }\n\n    if (h === constants.AUTO) {\n        h = this.bitmap.height * (w / this.bitmap.width);\n    }\n\n    if (w < 0 || h < 0) {\n        return throwError.call(this, 'w and h must be positive numbers', cb);\n    }\n\n    // round inputs\n    w = Math.round(w);\n    h = Math.round(h);\n\n    if (typeof Resize2[mode] === 'function') {\n        const dst = {\n            data: Buffer.alloc(w * h * 4),\n            width: w,\n            height: h\n        };\n        Resize2[mode](this.bitmap, dst);\n        this.bitmap = dst;\n    } else {\n        const image = this;\n        const resize = new Resize(\n            this.bitmap.width,\n            this.bitmap.height,\n            w,\n            h,\n            true,\n            true,\n            buffer => {\n                image.bitmap.data = Buffer.from(buffer);\n                image.bitmap.width = w;\n                image.bitmap.height = h;\n            }\n        );\n        resize.resize(this.bitmap.data);\n    }\n\n    if (isNodePattern(cb)) {\n        return cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Scale the image so the given width and height keeping the aspect ratio. Some parts of the image may be clipped.\n * @param {number} w the width to resize the image to\n * @param {number} h the height to resize the image to\n * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function cover(w, h, alignBits, mode, cb) {\n    if (typeof w !== 'number' || typeof h !== 'number') {\n        return throwError.call(this, 'w and h must be numbers', cb);\n    }\n\n    if (\n        alignBits &&\n        typeof alignBits === 'function' &&\n        typeof cb === 'undefined'\n    ) {\n        cb = alignBits;\n        alignBits = null;\n        mode = null;\n    } else if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n    }\n\n    alignBits =\n        alignBits || this.HORIZONTAL_ALIGN_CENTER | this.VERTICAL_ALIGN_MIDDLE;\n    const hbits = alignBits & ((1 << 3) - 1);\n    const vbits = alignBits >> 3;\n\n    // check if more flags than one is in the bit sets\n    if (\n        !(\n            (hbits !== 0 && !(hbits & (hbits - 1))) ||\n            (vbits !== 0 && !(vbits & (vbits - 1)))\n        )\n    )\n        return throwError.call(\n            this,\n            'only use one flag per alignment direction',\n            cb\n        );\n\n    const alignH = hbits >> 1; // 0, 1, 2\n    const alignV = vbits >> 1; // 0, 1, 2\n\n    const f =\n        w / h > this.bitmap.width / this.bitmap.height\n            ? w / this.bitmap.width\n            : h / this.bitmap.height;\n    this.scale(f, mode);\n    this.crop(\n        ((this.bitmap.width - w) / 2) * alignH,\n        ((this.bitmap.height - h) / 2) * alignV,\n        w,\n        h\n    );\n\n    if (isNodePattern(cb)) {\n        return cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Scale the image to the given width and height keeping the aspect ratio. Some parts of the image may be letter boxed.\n * @param {number} w the width to resize the image to\n * @param {number} h the height to resize the image to\n * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function contain(w, h, alignBits, mode, cb) {\n    if (typeof w !== 'number' || typeof h !== 'number') {\n        return throwError.call(this, 'w and h must be numbers', cb);\n    }\n\n    // permit any sort of optional parameters combination\n    if (typeof alignBits === 'string') {\n        if (typeof mode === 'function' && typeof cb === 'undefined') cb = mode;\n        mode = alignBits;\n        alignBits = null;\n    }\n\n    if (typeof alignBits === 'function') {\n        if (typeof cb === 'undefined') cb = alignBits;\n        mode = null;\n        alignBits = null;\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n    }\n\n    alignBits =\n        alignBits ||\n        constants.HORIZONTAL_ALIGN_CENTER | constants.VERTICAL_ALIGN_MIDDLE;\n    const hbits = alignBits & ((1 << 3) - 1);\n    const vbits = alignBits >> 3;\n\n    // check if more flags than one is in the bit sets\n    if (\n        !(\n            (hbits !== 0 && !(hbits & (hbits - 1))) ||\n            (vbits !== 0 && !(vbits & (vbits - 1)))\n        )\n    ) {\n        return throwError.call(\n            this,\n            'only use one flag per alignment direction',\n            cb\n        );\n    }\n\n    const alignH = hbits >> 1; // 0, 1, 2\n    const alignV = vbits >> 1; // 0, 1, 2\n\n    const f =\n        w / h > this.bitmap.width / this.bitmap.height\n            ? h / this.bitmap.height\n            : w / this.bitmap.width;\n    const c = this.cloneQuiet().scale(f, mode);\n\n    this.resize(w, h, mode);\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n        x,\n        y,\n        idx\n    ) {\n        this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n    this.blit(\n        c,\n        ((this.bitmap.width - c.bitmap.width) / 2) * alignH,\n        ((this.bitmap.height - c.bitmap.height) / 2) * alignV\n    );\n\n    if (isNodePattern(cb)) {\n        return cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Uniformly scales the image by a factor.\n * @param {number} f the factor to scale the image by\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function scale(f, mode, cb) {\n    if (typeof f !== 'number') {\n        return throwError.call(this, 'f must be a number', cb);\n    }\n\n    if (f < 0) {\n        return throwError.call(this, 'f must be a positive number', cb);\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n    }\n\n    const w = this.bitmap.width * f;\n    const h = this.bitmap.height * f;\n    this.resize(w, h, mode);\n\n    if (isNodePattern(cb)) {\n        return cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Scale the image to the largest size that fits inside the rectangle that has the given width and height.\n * @param {number} w the width to resize the image to\n * @param {number} h the height to resize the image to\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function scaleToFit(w, h, mode, cb) {\n    if (typeof w !== 'number' || typeof h !== 'number') {\n        return throwError.call(this, 'w and h must be numbers', cb);\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n    }\n\n    const f =\n        w / h > this.bitmap.width / this.bitmap.height\n            ? h / this.bitmap.height\n            : w / this.bitmap.width;\n    this.scale(f, mode);\n\n    if (isNodePattern(cb)) {\n        return cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Displaces the image based on the provided displacement map\n * @param {object} map the source Jimp instance\n * @param {number} offset the maximum displacement value\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function displace(map, offset, cb) {\n    if (typeof map !== 'object' || map.constructor !== this.constructor) {\n        return throwError.call(this, 'The source must be a Jimp image', cb);\n    }\n\n    if (typeof offset !== 'number') {\n        return throwError.call(this, 'factor must be a number', cb);\n    }\n\n    const source = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n        x,\n        y,\n        idx\n    ) {\n        let displacement = (map.bitmap.data[idx] / 256) * offset;\n        displacement = Math.round(displacement);\n\n        const ids = this.getPixelIndex(x + displacement, y);\n        this.bitmap.data[ids] = source.bitmap.data[idx];\n        this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];\n        this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];\n    });\n\n    if (isNodePattern(cb)) {\n        return cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Autocrop same color borders from this image\n * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)\n * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)\n * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)\n * @returns {Jimp} this for chaining of methods\n */\nexport function autocrop(...args) {\n    const w = this.bitmap.width;\n    const h = this.bitmap.height;\n    const minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image\n\n    let cb; // callback\n    let tolerance = 0.0002; // percent of color difference tolerance (default value)\n    let cropOnlyFrames = true; // flag to force cropping only if the image has a real \"frame\"\n    // i.e. all 4 sides have some border (default value)\n\n    // parse arguments\n    for (let a = 0, len = args.length; a < len; a++) {\n        if (typeof args[a] === 'number') {\n            // tolerance value passed\n            tolerance = args[a];\n        }\n\n        if (typeof args[a] === 'boolean') {\n            // cropOnlyFrames value passed\n            cropOnlyFrames = args[a];\n        }\n\n        if (typeof args[a] === 'function') {\n            // callback value passed\n            cb = args[a];\n        }\n    }\n\n    /**\n     * All borders must be of the same color as the top left pixel, to be cropped.\n     * It should be possible to crop borders each with a different color,\n     * but since there are many ways for corners to intersect, it would\n     * introduce unnecessary complexity to the algorithm.\n     */\n\n    // scan each side for same color borders\n    const colorTarget = this.getPixelColor(0, 0); // top left pixel color is the target color\n    const rgba1 = this.constructor.intToRGBA(colorTarget);\n\n    // for north and east sides\n    let northPixelsToCrop = 0;\n    let eastPixelsToCrop = 0;\n    let southPixelsToCrop = 0;\n    let westPixelsToCrop = 0;\n\n    // north side (scan rows from north to south)\n    north: for (let y = 0; y < h - minPixelsPerSide; y++) {\n        for (let x = 0; x < w; x++) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break north;\n            }\n        }\n        // this row contains all pixels with the same color: increment this side pixels to crop\n        northPixelsToCrop++;\n    }\n\n    // east side (scan columns from east to west)\n    east: for (let x = 0; x < w - minPixelsPerSide; x++) {\n        for (let y = 0 + northPixelsToCrop; y < h; y++) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break east;\n            }\n        }\n        // this column contains all pixels with the same color: increment this side pixels to crop\n        eastPixelsToCrop++;\n    }\n\n    // south side (scan rows from south to north)\n    south: for (let y = h - 1; y >= northPixelsToCrop + minPixelsPerSide; y--) {\n        for (let x = w - eastPixelsToCrop - 1; x >= 0; x--) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break south;\n            }\n        }\n        // this row contains all pixels with the same color: increment this side pixels to crop\n        southPixelsToCrop++;\n    }\n\n    // west side (scan columns from west to east)\n    west: for (\n        let x = w - 1;\n        x >= 0 + eastPixelsToCrop + minPixelsPerSide;\n        x--\n    ) {\n        for (let y = h - 1; y >= 0 + northPixelsToCrop; y--) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break west;\n            }\n        }\n        // this column contains all pixels with the same color: increment this side pixels to crop\n        westPixelsToCrop++;\n    }\n\n    // safety checks\n    const widthOfPixelsToCrop = w - (westPixelsToCrop + eastPixelsToCrop);\n    // widthOfPixelsToCrop >= 0 ? widthOfPixelsToCrop : 0;\n    const heightOfPixelsToCrop = h - (southPixelsToCrop + northPixelsToCrop);\n    // heightOfPixelsToCrop >= 0 ? heightOfPixelsToCrop : 0;\n\n    // decide if a crop is needed\n    let doCrop = false;\n\n    if (cropOnlyFrames) {\n        // crop image if all sides should be cropped\n        doCrop =\n            eastPixelsToCrop !== 0 &&\n            northPixelsToCrop !== 0 &&\n            westPixelsToCrop !== 0 &&\n            southPixelsToCrop !== 0;\n    } else {\n        // crop image if at least one side should be cropped\n        doCrop =\n            eastPixelsToCrop !== 0 ||\n            northPixelsToCrop !== 0 ||\n            westPixelsToCrop !== 0 ||\n            southPixelsToCrop !== 0;\n    }\n\n    if (doCrop) {\n        // do the real crop\n        this.crop(\n            eastPixelsToCrop,\n            northPixelsToCrop,\n            widthOfPixelsToCrop,\n            heightOfPixelsToCrop\n        );\n    }\n\n    if (isNodePattern(cb)) {\n        return cb.call(this, null, this);\n    }\n\n    return this;\n}\n"],"file":"shape.js"}