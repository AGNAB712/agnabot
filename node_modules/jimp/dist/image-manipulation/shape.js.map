{"version":3,"sources":["../../src/image-manipulation/shape.js"],"names":["rotate90degrees","bitmap","dstBuffer","clockwise","dstOffsetStep","dstOffset","length","tmp","x","y","srcOffset","width","height","data","readUInt32BE","writeUInt32BE","simpleRotate","deg","steps","Math","round","srcBuffer","len","Buffer","allocUnsafe","advancedRotate","mode","rad","PI","cosine","cos","sine","sin","w","h","ceil","abs","c","cloneQuiet","scanQuiet","idx","_background","max","resize","blit","bW","bH","alloc","createTranslationFunction","deltaX","deltaY","translate2Cartesian","translate2Screen","cartesian","source","dstIdx","srcIdx","pixelRGBA","crop","rotate","cb","throwError","call","Boolean","flipFn","horizontal","vertical","_x","_y","_idx","from","flip","mirror","constants","AUTO","Resize2","dst","image","Resize","buffer","cover","alignBits","HORIZONTAL_ALIGN_CENTER","VERTICAL_ALIGN_MIDDLE","hbits","vbits","alignH","alignV","f","scale","contain","scaleToFit","displace","map","offset","constructor","displacement","ids","getPixelIndex","autocrop","minPixelsPerSide","tolerance","cropOnlyFrames","a","colorTarget","getPixelColor","rgba1","intToRGBA","northPixelsToCrop","eastPixelsToCrop","southPixelsToCrop","westPixelsToCrop","north","colorXY","rgba2","colorDiff","east","south","west","widthOfPixelsToCrop","heightOfPixelsToCrop","doCrop"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAEA;;AACA;;AAEA;;AACA;;;;;;;;AAEA,SAASA,eAAT,CAAyBC,MAAzB,EAAiCC,SAAjC,EAA4CC,SAA5C,EAAuD;AACnD,MAAMC,aAAa,GAAGD,SAAS,GAAG,CAAC,CAAJ,GAAQ,CAAvC;AACA,MAAIE,SAAS,GAAGF,SAAS,GAAGD,SAAS,CAACI,MAAV,GAAmB,CAAtB,GAA0B,CAAnD;AAEA,MAAIC,GAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,SAAJ;;AAEA,OAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGP,MAAM,CAACU,KAAvB,EAA8BH,CAAC,EAA/B,EAAmC;AAC/B,SAAKC,CAAC,GAAGR,MAAM,CAACW,MAAP,GAAgB,CAAzB,EAA4BH,CAAC,IAAI,CAAjC,EAAoCA,CAAC,EAArC,EAAyC;AACrCC,MAAAA,SAAS,GAAIT,MAAM,CAACU,KAAP,GAAeF,CAAf,GAAmBD,CAApB,IAA0B,CAAtC;AACAD,MAAAA,GAAG,GAAGN,MAAM,CAACY,IAAP,CAAYC,YAAZ,CAAyBJ,SAAzB,EAAoC,IAApC,CAAN;AACAR,MAAAA,SAAS,CAACa,aAAV,CAAwBR,GAAxB,EAA6BF,SAA7B,EAAwC,IAAxC;AACAA,MAAAA,SAAS,IAAID,aAAb;AACH;AACJ;AACJ;AAED;;;;;;AAIA,SAASY,YAAT,CAAsBC,GAAtB,EAA2B;AACvB,MAAIC,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWH,GAAG,GAAG,EAAjB,IAAuB,CAAnC;AACAC,EAAAA,KAAK,IAAIA,KAAK,GAAG,CAAR,GAAY,CAAZ,GAAgB,CAAzB;AAEA,MAAIA,KAAK,KAAK,CAAd,EAAiB;AAEjB,MAAMG,SAAS,GAAG,KAAKpB,MAAL,CAAYY,IAA9B;AACA,MAAMS,GAAG,GAAGD,SAAS,CAACf,MAAtB;AACA,MAAMJ,SAAS,GAAGqB,MAAM,CAACC,WAAP,CAAmBF,GAAnB,CAAlB;AAEA,MAAIf,GAAJ;;AAEA,MAAIW,KAAK,KAAK,CAAd,EAAiB;AACb;AACA,SAAK,IAAIR,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAGY,GAApC,EAAyCZ,SAAS,IAAI,CAAtD,EAAyD;AACrDH,MAAAA,GAAG,GAAGc,SAAS,CAACP,YAAV,CAAuBJ,SAAvB,EAAkC,IAAlC,CAAN;AACAR,MAAAA,SAAS,CAACa,aAAV,CAAwBR,GAAxB,EAA6Be,GAAG,GAAGZ,SAAN,GAAkB,CAA/C,EAAkD,IAAlD;AACH;AACJ,GAND,MAMO;AACH;AACAV,IAAAA,eAAe,CAAC,KAAKC,MAAN,EAAcC,SAAd,EAAyBgB,KAAK,KAAK,CAAnC,CAAf;AAEAX,IAAAA,GAAG,GAAG,KAAKN,MAAL,CAAYU,KAAlB;AACA,SAAKV,MAAL,CAAYU,KAAZ,GAAoB,KAAKV,MAAL,CAAYW,MAAhC;AACA,SAAKX,MAAL,CAAYW,MAAZ,GAAqBL,GAArB;AACH;;AAED,OAAKN,MAAL,CAAYY,IAAZ,GAAmBX,SAAnB;AACH;AAED;;;;;;;AAKA,SAASuB,cAAT,CAAwBR,GAAxB,EAA6BS,IAA7B,EAAmC;AAC/BT,EAAAA,GAAG,IAAI,GAAP;AACA,MAAMU,GAAG,GAAIV,GAAG,GAAGE,IAAI,CAACS,EAAZ,GAAkB,GAA9B;AACA,MAAMC,MAAM,GAAGV,IAAI,CAACW,GAAL,CAASH,GAAT,CAAf;AACA,MAAMI,IAAI,GAAGZ,IAAI,CAACa,GAAL,CAASL,GAAT,CAAb,CAJ+B,CAM/B;;AACA,MAAIM,CAAC,GAAG,KAAKhC,MAAL,CAAYU,KAApB;AACA,MAAIuB,CAAC,GAAG,KAAKjC,MAAL,CAAYW,MAApB;;AAEA,MAAIc,IAAI,KAAK,IAAT,IAAiB,OAAOA,IAAP,KAAgB,QAArC,EAA+C;AAC3C;AACA;AAEA;AACA;AACAO,IAAAA,CAAC,GACGd,IAAI,CAACgB,IAAL,CACIhB,IAAI,CAACiB,GAAL,CAAS,KAAKnC,MAAL,CAAYU,KAAZ,GAAoBkB,MAA7B,IACIV,IAAI,CAACiB,GAAL,CAAS,KAAKnC,MAAL,CAAYW,MAAZ,GAAqBmB,IAA9B,CAFR,IAGI,CAJR;AAKAG,IAAAA,CAAC,GACGf,IAAI,CAACgB,IAAL,CACIhB,IAAI,CAACiB,GAAL,CAAS,KAAKnC,MAAL,CAAYU,KAAZ,GAAoBoB,IAA7B,IACIZ,IAAI,CAACiB,GAAL,CAAS,KAAKnC,MAAL,CAAYW,MAAZ,GAAqBiB,MAA9B,CAFR,IAGI,CAJR,CAX2C,CAgB3C;;AACA,QAAII,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiB;AACbA,MAAAA,CAAC;AACJ;;AAED,QAAIC,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiB;AACbA,MAAAA,CAAC;AACJ;;AAED,QAAMG,CAAC,GAAG,KAAKC,UAAL,EAAV;AACA,SAAKC,SAAL,CAAe,CAAf,EAAkB,CAAlB,EAAqB,KAAKtC,MAAL,CAAYU,KAAjC,EAAwC,KAAKV,MAAL,CAAYW,MAApD,EAA4D,UACxDJ,CADwD,EAExDC,CAFwD,EAGxD+B,GAHwD,EAI1D;AACE,WAAKvC,MAAL,CAAYY,IAAZ,CAAiBE,aAAjB,CAA+B,KAAK0B,WAApC,EAAiDD,GAAjD;AACH,KAND;AAQA,QAAME,GAAG,GAAGvB,IAAI,CAACuB,GAAL,CAAST,CAAT,EAAYC,CAAZ,EAAe,KAAKjC,MAAL,CAAYU,KAA3B,EAAkC,KAAKV,MAAL,CAAYW,MAA9C,CAAZ;AACA,SAAK+B,MAAL,CAAYD,GAAZ,EAAiBA,GAAjB,EAAsBhB,IAAtB;AAEA,SAAKkB,IAAL,CACIP,CADJ,EAEI,KAAKpC,MAAL,CAAYU,KAAZ,GAAoB,CAApB,GAAwB0B,CAAC,CAACpC,MAAF,CAASU,KAAT,GAAiB,CAF7C,EAGI,KAAKV,MAAL,CAAYW,MAAZ,GAAqB,CAArB,GAAyByB,CAAC,CAACpC,MAAF,CAASW,MAAT,GAAkB,CAH/C;AAKH;;AAED,MAAMiC,EAAE,GAAG,KAAK5C,MAAL,CAAYU,KAAvB;AACA,MAAMmC,EAAE,GAAG,KAAK7C,MAAL,CAAYW,MAAvB;AACA,MAAMV,SAAS,GAAGqB,MAAM,CAACwB,KAAP,CAAa,KAAK9C,MAAL,CAAYY,IAAZ,CAAiBP,MAA9B,CAAlB;;AAEA,WAAS0C,yBAAT,CAAmCC,MAAnC,EAA2CC,MAA3C,EAAmD;AAC/C,WAAO,UAAS1C,CAAT,EAAYC,CAAZ,EAAe;AAClB,aAAO;AACHD,QAAAA,CAAC,EAAEA,CAAC,GAAGyC,MADJ;AAEHxC,QAAAA,CAAC,EAAEA,CAAC,GAAGyC;AAFJ,OAAP;AAIH,KALD;AAMH;;AAED,MAAMC,mBAAmB,GAAGH,yBAAyB,CAAC,EAAEH,EAAE,GAAG,CAAP,CAAD,EAAY,EAAEC,EAAE,GAAG,CAAP,CAAZ,CAArD;AACA,MAAMM,gBAAgB,GAAGJ,yBAAyB,CAC9CH,EAAE,GAAG,CAAL,GAAS,GADqC,EAE9CC,EAAE,GAAG,CAAL,GAAS,GAFqC,CAAlD;;AAKA,OAAK,IAAIrC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIqC,EAArB,EAAyBrC,CAAC,EAA1B,EAA8B;AAC1B,SAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIqC,EAArB,EAAyBrC,CAAC,EAA1B,EAA8B;AAC1B,UAAM6C,SAAS,GAAGF,mBAAmB,CAAC3C,CAAD,EAAIC,CAAJ,CAArC;AACA,UAAM6C,MAAM,GAAGF,gBAAgB,CAC3BvB,MAAM,GAAGwB,SAAS,CAAC7C,CAAnB,GAAuBuB,IAAI,GAAGsB,SAAS,CAAC5C,CADb,EAE3BoB,MAAM,GAAGwB,SAAS,CAAC5C,CAAnB,GAAuBsB,IAAI,GAAGsB,SAAS,CAAC7C,CAFb,CAA/B;AAIA,UAAM+C,MAAM,GAAIV,EAAE,IAAIpC,CAAC,GAAG,CAAR,CAAF,GAAeD,CAAf,GAAmB,CAApB,IAA0B,CAAzC;;AAEA,UACI8C,MAAM,CAAC9C,CAAP,IAAY,CAAZ,IACA8C,MAAM,CAAC9C,CAAP,GAAWqC,EADX,IAEAS,MAAM,CAAC7C,CAAP,IAAY,CAFZ,IAGA6C,MAAM,CAAC7C,CAAP,GAAWqC,EAJf,EAKE;AACE,YAAMU,MAAM,GAAG,CAAEX,EAAE,IAAIS,MAAM,CAAC7C,CAAP,GAAW,CAAf,CAAF,GAAsB6C,MAAM,CAAC9C,CAA9B,GAAmC,CAApC,KAA0C,CAAzD;AACA,YAAMiD,SAAS,GAAG,KAAKxD,MAAL,CAAYY,IAAZ,CAAiBC,YAAjB,CAA8B0C,MAA9B,CAAlB;AACAtD,QAAAA,SAAS,CAACa,aAAV,CAAwB0C,SAAxB,EAAmCF,MAAnC;AACH,OATD,MASO;AACH;AACArD,QAAAA,SAAS,CAACa,aAAV,CAAwB,KAAK0B,WAA7B,EAA0Cc,MAA1C;AACH;AACJ;AACJ;;AACD,OAAKtD,MAAL,CAAYY,IAAZ,GAAmBX,SAAnB;;AAEA,MAAIwB,IAAI,KAAK,IAAT,IAAiB,OAAOA,IAAP,KAAgB,QAArC,EAA+C;AAC3C;AACA,QAAMlB,GAAC,GAAGqC,EAAE,GAAG,CAAL,GAASZ,CAAC,GAAG,CAAvB;;AACA,QAAMxB,GAAC,GAAGqC,EAAE,GAAG,CAAL,GAASZ,CAAC,GAAG,CAAvB;;AACA,SAAKwB,IAAL,CAAUlD,GAAV,EAAaC,GAAb,EAAgBwB,CAAhB,EAAmBC,CAAnB;AACH;AACJ;AAED;;;;;;;;;AAOO,SAASyB,MAAT,CAAgB1C,GAAhB,EAAqBS,IAArB,EAA2BkC,EAA3B,EAA+B;AAClC;AACA,MAAI,OAAOlC,IAAP,KAAgB,WAAhB,IAA+BA,IAAI,KAAK,IAA5C,EAAkD;AAC9C;AACA;AACA;AACAA,IAAAA,IAAI,GAAG,IAAP;AACH;;AAED,MAAI,OAAOA,IAAP,KAAgB,UAAhB,IAA8B,OAAOkC,EAAP,KAAc,WAAhD,EAA6D;AACzD;AACAA,IAAAA,EAAE,GAAGlC,IAAL;AACAA,IAAAA,IAAI,GAAG,IAAP;AACH;;AAED,MAAI,OAAOT,GAAP,KAAe,QAAnB,EAA6B;AACzB,WAAO4C,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,sBAAtB,EAA8CF,EAA9C,CAAP;AACH;;AAED,MAAI,OAAOlC,IAAP,KAAgB,SAAhB,IAA6B,OAAOA,IAAP,KAAgB,QAAjD,EAA2D;AACvD,WAAOmC,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,oCAAtB,EAA4DF,EAA5D,CAAP;AACH;;AAED,MAAI3C,GAAG,GAAG,EAAN,KAAa,CAAb,IAAkB8C,OAAO,CAACrC,IAAD,CAAP,KAAkB,KAAxC,EAA+C;AAC3CV,IAAAA,YAAY,CAAC8C,IAAb,CAAkB,IAAlB,EAAwB7C,GAAxB,EAA6B2C,EAA7B;AACH,GAFD,MAEO;AACHnC,IAAAA,cAAc,CAACqC,IAAf,CAAoB,IAApB,EAA0B7C,GAA1B,EAA+BS,IAA/B,EAAqCkC,EAArC;AACH;;AAED,MAAI,kCAAcA,EAAd,CAAJ,EAAuB;AACnBA,IAAAA,EAAE,CAACE,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACH;;AAED,SAAO,IAAP;AACH;AAED;;;;;;;;;AAOA,SAASE,MAAT,CAAgBC,UAAhB,EAA4BC,QAA5B,EAAsCN,EAAtC,EAA0C;AACtC,MAAI,OAAOK,UAAP,KAAsB,SAAtB,IAAmC,OAAOC,QAAP,KAAoB,SAA3D,EACI,OAAOL,0BAAWC,IAAX,CACH,IADG,EAEH,0CAFG,EAGHF,EAHG,CAAP;;AAMJ,MAAIK,UAAU,IAAIC,QAAlB,EAA4B;AACxB;AACA,WAAO,KAAKP,MAAL,CAAY,GAAZ,EAAiB,IAAjB,EAAuBC,EAAvB,CAAP;AACH;;AAED,MAAM3D,MAAM,GAAGsB,MAAM,CAACwB,KAAP,CAAa,KAAK9C,MAAL,CAAYY,IAAZ,CAAiBP,MAA9B,CAAf;AACA,OAAKiC,SAAL,CAAe,CAAf,EAAkB,CAAlB,EAAqB,KAAKtC,MAAL,CAAYU,KAAjC,EAAwC,KAAKV,MAAL,CAAYW,MAApD,EAA4D,UACxDJ,CADwD,EAExDC,CAFwD,EAGxD+B,GAHwD,EAI1D;AACE,QAAM2B,EAAE,GAAGF,UAAU,GAAG,KAAKhE,MAAL,CAAYU,KAAZ,GAAoB,CAApB,GAAwBH,CAA3B,GAA+BA,CAApD;;AACA,QAAM4D,EAAE,GAAGF,QAAQ,GAAG,KAAKjE,MAAL,CAAYW,MAAZ,GAAqB,CAArB,GAAyBH,CAA5B,GAAgCA,CAAnD;;AACA,QAAM4D,IAAI,GAAI,KAAKpE,MAAL,CAAYU,KAAZ,GAAoByD,EAApB,GAAyBD,EAA1B,IAAiC,CAA9C;;AACA,QAAMtD,IAAI,GAAG,KAAKZ,MAAL,CAAYY,IAAZ,CAAiBC,YAAjB,CAA8B0B,GAA9B,CAAb;AAEAvC,IAAAA,MAAM,CAACc,aAAP,CAAqBF,IAArB,EAA2BwD,IAA3B;AACH,GAXD;AAaA,OAAKpE,MAAL,CAAYY,IAAZ,GAAmBU,MAAM,CAAC+C,IAAP,CAAYrE,MAAZ,CAAnB;;AAEA,MAAI,kCAAc2D,EAAd,CAAJ,EAAuB;AACnBA,IAAAA,EAAE,CAACE,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACH;;AAED,SAAO,IAAP;AACH;;AAEM,IAAMS,IAAI,GAAGP,MAAb;;AACA,IAAMQ,MAAM,GAAGR,MAAf;AAEP;;;;;;;;;;;AAQO,SAASrB,MAAT,CAAgBV,CAAhB,EAAmBC,CAAnB,EAAsBR,IAAtB,EAA4BkC,EAA5B,EAAgC;AACnC,MAAI,OAAO3B,CAAP,KAAa,QAAb,IAAyB,OAAOC,CAAP,KAAa,QAA1C,EAAoD;AAChD,WAAO2B,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,yBAAtB,EAAiDF,EAAjD,CAAP;AACH;;AAED,MAAI,OAAOlC,IAAP,KAAgB,UAAhB,IAA8B,OAAOkC,EAAP,KAAc,WAAhD,EAA6D;AACzDA,IAAAA,EAAE,GAAGlC,IAAL;AACAA,IAAAA,IAAI,GAAG,IAAP;AACH;;AAED,MAAIO,CAAC,KAAKwC,SAAS,CAACC,IAAhB,IAAwBxC,CAAC,KAAKuC,SAAS,CAACC,IAA5C,EAAkD;AAC9C,WAAOb,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,oCAAtB,EAA4DF,EAA5D,CAAP;AACH;;AAED,MAAI3B,CAAC,KAAKwC,SAAS,CAACC,IAApB,EAA0B;AACtBzC,IAAAA,CAAC,GAAG,KAAKhC,MAAL,CAAYU,KAAZ,IAAqBuB,CAAC,GAAG,KAAKjC,MAAL,CAAYW,MAArC,CAAJ;AACH;;AAED,MAAIsB,CAAC,KAAKuC,SAAS,CAACC,IAApB,EAA0B;AACtBxC,IAAAA,CAAC,GAAG,KAAKjC,MAAL,CAAYW,MAAZ,IAAsBqB,CAAC,GAAG,KAAKhC,MAAL,CAAYU,KAAtC,CAAJ;AACH;;AAED,MAAIsB,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAjB,EAAoB;AAChB,WAAO2B,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,kCAAtB,EAA0DF,EAA1D,CAAP;AACH,GAxBkC,CA0BnC;;;AACA3B,EAAAA,CAAC,GAAGd,IAAI,CAACC,KAAL,CAAWa,CAAX,CAAJ;AACAC,EAAAA,CAAC,GAAGf,IAAI,CAACC,KAAL,CAAWc,CAAX,CAAJ;;AAEA,MAAI,OAAOyC,iBAAQjD,IAAR,CAAP,KAAyB,UAA7B,EAAyC;AACrC,QAAMkD,GAAG,GAAG;AACR/D,MAAAA,IAAI,EAAEU,MAAM,CAACwB,KAAP,CAAad,CAAC,GAAGC,CAAJ,GAAQ,CAArB,CADE;AAERvB,MAAAA,KAAK,EAAEsB,CAFC;AAGRrB,MAAAA,MAAM,EAAEsB;AAHA,KAAZ;;AAKAyC,qBAAQjD,IAAR,EAAc,KAAKzB,MAAnB,EAA2B2E,GAA3B;;AACA,SAAK3E,MAAL,GAAc2E,GAAd;AACH,GARD,MAQO;AACH,QAAMC,KAAK,GAAG,IAAd;;AACA,QAAMlC,OAAM,GAAG,IAAImC,gBAAJ,CACX,KAAK7E,MAAL,CAAYU,KADD,EAEX,KAAKV,MAAL,CAAYW,MAFD,EAGXqB,CAHW,EAIXC,CAJW,EAKX,IALW,EAMX,IANW,EAOX,UAAA6C,MAAM,EAAI;AACNF,MAAAA,KAAK,CAAC5E,MAAN,CAAaY,IAAb,GAAoBU,MAAM,CAAC+C,IAAP,CAAYS,MAAZ,CAApB;AACAF,MAAAA,KAAK,CAAC5E,MAAN,CAAaU,KAAb,GAAqBsB,CAArB;AACA4C,MAAAA,KAAK,CAAC5E,MAAN,CAAaW,MAAb,GAAsBsB,CAAtB;AACH,KAXU,CAAf;;AAaAS,IAAAA,OAAM,CAACA,MAAP,CAAc,KAAK1C,MAAL,CAAYY,IAA1B;AACH;;AAED,MAAI,kCAAc+C,EAAd,CAAJ,EAAuB;AACnBA,IAAAA,EAAE,CAACE,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACH;;AAED,SAAO,IAAP;AACH;AAED;;;;;;;;;;;AASO,SAASkB,KAAT,CAAe/C,CAAf,EAAkBC,CAAlB,EAAqB+C,SAArB,EAAgCvD,IAAhC,EAAsCkC,EAAtC,EAA0C;AAC7C,MAAI,OAAO3B,CAAP,KAAa,QAAb,IAAyB,OAAOC,CAAP,KAAa,QAA1C,EAAoD;AAChD,WAAO2B,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,yBAAtB,EAAiDF,EAAjD,CAAP;AACH;;AAED,MACIqB,SAAS,IACT,OAAOA,SAAP,KAAqB,UADrB,IAEA,OAAOrB,EAAP,KAAc,WAHlB,EAIE;AACEA,IAAAA,EAAE,GAAGqB,SAAL;AACAA,IAAAA,SAAS,GAAG,IAAZ;AACAvD,IAAAA,IAAI,GAAG,IAAP;AACH,GARD,MAQO,IAAI,OAAOA,IAAP,KAAgB,UAAhB,IAA8B,OAAOkC,EAAP,KAAc,WAAhD,EAA6D;AAChEA,IAAAA,EAAE,GAAGlC,IAAL;AACAA,IAAAA,IAAI,GAAG,IAAP;AACH;;AAEDuD,EAAAA,SAAS,GACLA,SAAS,IACTR,SAAS,CAACS,uBAAV,GAAoCT,SAAS,CAACU,qBAFlD;AAGA,MAAMC,KAAK,GAAGH,SAAS,GAAI,CAAC,KAAK,CAAN,IAAW,CAAtC;AACA,MAAMI,KAAK,GAAGJ,SAAS,IAAI,CAA3B,CAtB6C,CAwB7C;;AACA,MACI,EACKG,KAAK,KAAK,CAAV,IAAe,EAAEA,KAAK,GAAIA,KAAK,GAAG,CAAnB,CAAhB,IACCC,KAAK,KAAK,CAAV,IAAe,EAAEA,KAAK,GAAIA,KAAK,GAAG,CAAnB,CAFpB,CADJ,EAMI,OAAOxB,0BAAWC,IAAX,CACH,IADG,EAEH,2CAFG,EAGHF,EAHG,CAAP;AAMJ,MAAM0B,MAAM,GAAGF,KAAK,IAAI,CAAxB,CArC6C,CAqClB;;AAC3B,MAAMG,MAAM,GAAGF,KAAK,IAAI,CAAxB,CAtC6C,CAsClB;;AAE3B,MAAMG,CAAC,GACHvD,CAAC,GAAGC,CAAJ,GAAQ,KAAKjC,MAAL,CAAYU,KAAZ,GAAoB,KAAKV,MAAL,CAAYW,MAAxC,GACMqB,CAAC,GAAG,KAAKhC,MAAL,CAAYU,KADtB,GAEMuB,CAAC,GAAG,KAAKjC,MAAL,CAAYW,MAH1B;AAIA,OAAK6E,KAAL,CAAWD,CAAX,EAAc9D,IAAd;AACA,OAAKgC,IAAL,CACK,CAAC,KAAKzD,MAAL,CAAYU,KAAZ,GAAoBsB,CAArB,IAA0B,CAA3B,GAAgCqD,MADpC,EAEK,CAAC,KAAKrF,MAAL,CAAYW,MAAZ,GAAqBsB,CAAtB,IAA2B,CAA5B,GAAiCqD,MAFrC,EAGItD,CAHJ,EAIIC,CAJJ;;AAOA,MAAI,kCAAc0B,EAAd,CAAJ,EAAuB;AACnBA,IAAAA,EAAE,CAACE,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACH;;AAED,SAAO,IAAP;AACH;AAED;;;;;;;;;;;AASO,SAAS4B,OAAT,CAAiBzD,CAAjB,EAAoBC,CAApB,EAAuB+C,SAAvB,EAAkCvD,IAAlC,EAAwCkC,EAAxC,EAA4C;AAC/C,MAAI,OAAO3B,CAAP,KAAa,QAAb,IAAyB,OAAOC,CAAP,KAAa,QAA1C,EAAoD;AAChD,WAAO2B,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,yBAAtB,EAAiDF,EAAjD,CAAP;AACH,GAH8C,CAK/C;;;AACA,MAAI,OAAOqB,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,QAAI,OAAOvD,IAAP,KAAgB,UAAhB,IAA8B,OAAOkC,EAAP,KAAc,WAAhD,EAA6DA,EAAE,GAAGlC,IAAL;AAC7DA,IAAAA,IAAI,GAAGuD,SAAP;AACAA,IAAAA,SAAS,GAAG,IAAZ;AACH;;AAED,MAAI,OAAOA,SAAP,KAAqB,UAAzB,EAAqC;AACjC,QAAI,OAAOrB,EAAP,KAAc,WAAlB,EAA+BA,EAAE,GAAGqB,SAAL;AAC/BvD,IAAAA,IAAI,GAAG,IAAP;AACAuD,IAAAA,SAAS,GAAG,IAAZ;AACH;;AAED,MAAI,OAAOvD,IAAP,KAAgB,UAAhB,IAA8B,OAAOkC,EAAP,KAAc,WAAhD,EAA6D;AACzDA,IAAAA,EAAE,GAAGlC,IAAL;AACAA,IAAAA,IAAI,GAAG,IAAP;AACH;;AAEDuD,EAAAA,SAAS,GACLA,SAAS,IACTR,SAAS,CAACS,uBAAV,GAAoCT,SAAS,CAACU,qBAFlD;AAGA,MAAMC,KAAK,GAAGH,SAAS,GAAI,CAAC,KAAK,CAAN,IAAW,CAAtC;AACA,MAAMI,KAAK,GAAGJ,SAAS,IAAI,CAA3B,CA3B+C,CA6B/C;;AACA,MACI,EACKG,KAAK,KAAK,CAAV,IAAe,EAAEA,KAAK,GAAIA,KAAK,GAAG,CAAnB,CAAhB,IACCC,KAAK,KAAK,CAAV,IAAe,EAAEA,KAAK,GAAIA,KAAK,GAAG,CAAnB,CAFpB,CADJ,EAKE;AACE,WAAOxB,0BAAWC,IAAX,CACH,IADG,EAEH,2CAFG,EAGHF,EAHG,CAAP;AAKH;;AAED,MAAM0B,MAAM,GAAGF,KAAK,IAAI,CAAxB,CA3C+C,CA2CpB;;AAC3B,MAAMG,MAAM,GAAGF,KAAK,IAAI,CAAxB,CA5C+C,CA4CpB;;AAE3B,MAAMG,CAAC,GACHvD,CAAC,GAAGC,CAAJ,GAAQ,KAAKjC,MAAL,CAAYU,KAAZ,GAAoB,KAAKV,MAAL,CAAYW,MAAxC,GACMsB,CAAC,GAAG,KAAKjC,MAAL,CAAYW,MADtB,GAEMqB,CAAC,GAAG,KAAKhC,MAAL,CAAYU,KAH1B;AAIA,MAAM0B,CAAC,GAAG,KAAKC,UAAL,GAAkBmD,KAAlB,CAAwBD,CAAxB,EAA2B9D,IAA3B,CAAV;AAEA,OAAKiB,MAAL,CAAYV,CAAZ,EAAeC,CAAf,EAAkBR,IAAlB;AACA,OAAKa,SAAL,CAAe,CAAf,EAAkB,CAAlB,EAAqB,KAAKtC,MAAL,CAAYU,KAAjC,EAAwC,KAAKV,MAAL,CAAYW,MAApD,EAA4D,UACxDJ,CADwD,EAExDC,CAFwD,EAGxD+B,GAHwD,EAI1D;AACE,SAAKvC,MAAL,CAAYY,IAAZ,CAAiBE,aAAjB,CAA+B,KAAK0B,WAApC,EAAiDD,GAAjD;AACH,GAND;AAOA,OAAKI,IAAL,CACIP,CADJ,EAEK,CAAC,KAAKpC,MAAL,CAAYU,KAAZ,GAAoB0B,CAAC,CAACpC,MAAF,CAASU,KAA9B,IAAuC,CAAxC,GAA6C2E,MAFjD,EAGK,CAAC,KAAKrF,MAAL,CAAYW,MAAZ,GAAqByB,CAAC,CAACpC,MAAF,CAASW,MAA/B,IAAyC,CAA1C,GAA+C2E,MAHnD;;AAMA,MAAI,kCAAc3B,EAAd,CAAJ,EAAuB;AACnBA,IAAAA,EAAE,CAACE,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACH;;AAED,SAAO,IAAP;AACH;AAED;;;;;;;;;AAOO,SAAS2B,KAAT,CAAeD,CAAf,EAAkB9D,IAAlB,EAAwBkC,EAAxB,EAA4B;AAC/B,MAAI,OAAO4B,CAAP,KAAa,QAAjB,EAA2B;AACvB,WAAO3B,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,oBAAtB,EAA4CF,EAA5C,CAAP;AACH;;AAED,MAAI4B,CAAC,GAAG,CAAR,EAAW;AACP,WAAO3B,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,6BAAtB,EAAqDF,EAArD,CAAP;AACH;;AAED,MAAI,OAAOlC,IAAP,KAAgB,UAAhB,IAA8B,OAAOkC,EAAP,KAAc,WAAhD,EAA6D;AACzDA,IAAAA,EAAE,GAAGlC,IAAL;AACAA,IAAAA,IAAI,GAAG,IAAP;AACH;;AAED,MAAMO,CAAC,GAAG,KAAKhC,MAAL,CAAYU,KAAZ,GAAoB6E,CAA9B;AACA,MAAMtD,CAAC,GAAG,KAAKjC,MAAL,CAAYW,MAAZ,GAAqB4E,CAA/B;AACA,OAAK7C,MAAL,CAAYV,CAAZ,EAAeC,CAAf,EAAkBR,IAAlB;;AAEA,MAAI,kCAAckC,EAAd,CAAJ,EAAuB;AACnBA,IAAAA,EAAE,CAACE,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACH;;AAED,SAAO,IAAP;AACH;AAED;;;;;;;;;;AAQO,SAAS6B,UAAT,CAAoB1D,CAApB,EAAuBC,CAAvB,EAA0BR,IAA1B,EAAgCkC,EAAhC,EAAoC;AACvC,MAAI,OAAO3B,CAAP,KAAa,QAAb,IAAyB,OAAOC,CAAP,KAAa,QAA1C,EAAoD;AAChD,WAAO2B,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,yBAAtB,EAAiDF,EAAjD,CAAP;AACH;;AAED,MAAI,OAAOlC,IAAP,KAAgB,UAAhB,IAA8B,OAAOkC,EAAP,KAAc,WAAhD,EAA6D;AACzDA,IAAAA,EAAE,GAAGlC,IAAL;AACAA,IAAAA,IAAI,GAAG,IAAP;AACH;;AAED,MAAM8D,CAAC,GACHvD,CAAC,GAAGC,CAAJ,GAAQ,KAAKjC,MAAL,CAAYU,KAAZ,GAAoB,KAAKV,MAAL,CAAYW,MAAxC,GACMsB,CAAC,GAAG,KAAKjC,MAAL,CAAYW,MADtB,GAEMqB,CAAC,GAAG,KAAKhC,MAAL,CAAYU,KAH1B;AAIA,OAAK8E,KAAL,CAAWD,CAAX,EAAc9D,IAAd;;AAEA,MAAI,kCAAckC,EAAd,CAAJ,EAAuB;AACnBA,IAAAA,EAAE,CAACE,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACH;;AAED,SAAO,IAAP;AACH;AAED;;;;;;;;;AAOO,SAAS8B,QAAT,CAAkBC,GAAlB,EAAuBC,MAAvB,EAA+BlC,EAA/B,EAAmC;AACtC,MAAI,QAAOiC,GAAP,MAAe,QAAf,IAA2BA,GAAG,CAACE,WAAJ,KAAoB,KAAKA,WAAxD,EAAqE;AACjE,WAAOlC,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,iCAAtB,EAAyDF,EAAzD,CAAP;AACH;;AAED,MAAI,OAAOkC,MAAP,KAAkB,QAAtB,EAAgC;AAC5B,WAAOjC,0BAAWC,IAAX,CAAgB,IAAhB,EAAsB,yBAAtB,EAAiDF,EAAjD,CAAP;AACH;;AAED,MAAMN,MAAM,GAAG,KAAKhB,UAAL,EAAf;AACA,OAAKC,SAAL,CAAe,CAAf,EAAkB,CAAlB,EAAqB,KAAKtC,MAAL,CAAYU,KAAjC,EAAwC,KAAKV,MAAL,CAAYW,MAApD,EAA4D,UACxDJ,CADwD,EAExDC,CAFwD,EAGxD+B,GAHwD,EAI1D;AACE,QAAIwD,YAAY,GAAIH,GAAG,CAAC5F,MAAJ,CAAWY,IAAX,CAAgB2B,GAAhB,IAAuB,GAAxB,GAA+BsD,MAAlD;AACAE,IAAAA,YAAY,GAAG7E,IAAI,CAACC,KAAL,CAAW4E,YAAX,CAAf;AAEA,QAAMC,GAAG,GAAG,KAAKC,aAAL,CAAmB1F,CAAC,GAAGwF,YAAvB,EAAqCvF,CAArC,CAAZ;AACA,SAAKR,MAAL,CAAYY,IAAZ,CAAiBoF,GAAjB,IAAwB3C,MAAM,CAACrD,MAAP,CAAcY,IAAd,CAAmB2B,GAAnB,CAAxB;AACA,SAAKvC,MAAL,CAAYY,IAAZ,CAAiBoF,GAAG,GAAG,CAAvB,IAA4B3C,MAAM,CAACrD,MAAP,CAAcY,IAAd,CAAmB2B,GAAG,GAAG,CAAzB,CAA5B;AACA,SAAKvC,MAAL,CAAYY,IAAZ,CAAiBoF,GAAG,GAAG,CAAvB,IAA4B3C,MAAM,CAACrD,MAAP,CAAcY,IAAd,CAAmB2B,GAAG,GAAG,CAAzB,CAA5B;AACH,GAZD;;AAcA,MAAI,kCAAcoB,EAAd,CAAJ,EAAuB;AACnBA,IAAAA,EAAE,CAACE,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACH;;AAED,SAAO,IAAP;AACH;AAED;;;;;;;;;AAOO,SAASqC,QAAT,GAA2B;AAC9B,MAAMlE,CAAC,GAAG,KAAKhC,MAAL,CAAYU,KAAtB;AACA,MAAMuB,CAAC,GAAG,KAAKjC,MAAL,CAAYW,MAAtB;AACA,MAAMwF,gBAAgB,GAAG,CAAzB,CAH8B,CAGF;;AAE5B,MAAIxC,EAAJ,CAL8B,CAKtB;;AACR,MAAIyC,SAAS,GAAG,MAAhB,CAN8B,CAMN;;AACxB,MAAIC,cAAc,GAAG,IAArB,CAP8B,CAOH;AAC3B;AAEA;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWjF,GAAG,GAAG,UAAKhB,MAA3B,EAAmCiG,CAAC,GAAGjF,GAAvC,EAA4CiF,CAAC,EAA7C,EAAiD;AAC7C,QAAI,QAAYA,CAAZ,4BAAYA,CAAZ,yBAAYA,CAAZ,OAAmB,QAAvB,EAAiC;AAC7B;AACAF,MAAAA,SAAS,GAAQE,CAAR,4BAAQA,CAAR,yBAAQA,CAAR,CAAT;AACH;;AAED,QAAI,QAAYA,CAAZ,4BAAYA,CAAZ,yBAAYA,CAAZ,OAAmB,SAAvB,EAAkC;AAC9B;AACAD,MAAAA,cAAc,GAAQC,CAAR,4BAAQA,CAAR,yBAAQA,CAAR,CAAd;AACH;;AAED,QAAI,QAAYA,CAAZ,4BAAYA,CAAZ,yBAAYA,CAAZ,OAAmB,UAAvB,EAAmC;AAC/B;AACA3C,MAAAA,EAAE,GAAQ2C,CAAR,4BAAQA,CAAR,yBAAQA,CAAR,CAAF;AACH;AACJ;AAED;;;;;;AAOA;;;AACA,MAAMC,WAAW,GAAG,KAAKC,aAAL,CAAmB,CAAnB,EAAsB,CAAtB,CAApB,CApC8B,CAoCgB;;AAC9C,MAAMC,KAAK,GAAG,KAAKX,WAAL,CAAiBY,SAAjB,CAA2BH,WAA3B,CAAd,CArC8B,CAuC9B;;AACA,MAAII,iBAAiB,GAAG,CAAxB;AACA,MAAIC,gBAAgB,GAAG,CAAvB;AACA,MAAIC,iBAAiB,GAAG,CAAxB;AACA,MAAIC,gBAAgB,GAAG,CAAvB,CA3C8B,CA6C9B;;AACAC,EAAAA,KAAK,EAAE,KAAK,IAAIvG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyB,CAAC,GAAGkE,gBAAxB,EAA0C3F,CAAC,EAA3C,EAA+C;AAClD,SAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyB,CAApB,EAAuBzB,CAAC,EAAxB,EAA4B;AACxB,UAAMyG,OAAO,GAAG,KAAKR,aAAL,CAAmBjG,CAAnB,EAAsBC,CAAtB,CAAhB;AACA,UAAMyG,KAAK,GAAG,KAAKnB,WAAL,CAAiBY,SAAjB,CAA2BM,OAA3B,CAAd;;AAEA,UAAI,KAAKlB,WAAL,CAAiBoB,SAAjB,CAA2BT,KAA3B,EAAkCQ,KAAlC,IAA2Cb,SAA/C,EAA0D;AACtD;AACA,cAAMW,KAAN;AACH;AACJ,KATiD,CAUlD;;;AACAJ,IAAAA,iBAAiB;AACpB,GA1D6B,CA4D9B;;;AACAQ,EAAAA,IAAI,EAAE,KAAK,IAAI5G,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGyB,CAAC,GAAGmE,gBAAxB,EAA0C5F,GAAC,EAA3C,EAA+C;AACjD,SAAK,IAAIC,GAAC,GAAG,IAAImG,iBAAjB,EAAoCnG,GAAC,GAAGyB,CAAxC,EAA2CzB,GAAC,EAA5C,EAAgD;AAC5C,UAAMwG,QAAO,GAAG,KAAKR,aAAL,CAAmBjG,GAAnB,EAAsBC,GAAtB,CAAhB;;AACA,UAAMyG,KAAK,GAAG,KAAKnB,WAAL,CAAiBY,SAAjB,CAA2BM,QAA3B,CAAd;;AAEA,UAAI,KAAKlB,WAAL,CAAiBoB,SAAjB,CAA2BT,KAA3B,EAAkCQ,KAAlC,IAA2Cb,SAA/C,EAA0D;AACtD;AACA,cAAMe,IAAN;AACH;AACJ,KATgD,CAUjD;;;AACAP,IAAAA,gBAAgB;AACnB,GAzE6B,CA2E9B;;;AACAQ,EAAAA,KAAK,EAAE,KAAK,IAAI5G,GAAC,GAAGyB,CAAC,GAAG,CAAjB,EAAoBzB,GAAC,IAAImG,iBAAiB,GAAGR,gBAA7C,EAA+D3F,GAAC,EAAhE,EAAoE;AACvE,SAAK,IAAID,GAAC,GAAGyB,CAAC,GAAG4E,gBAAJ,GAAuB,CAApC,EAAuCrG,GAAC,IAAI,CAA5C,EAA+CA,GAAC,EAAhD,EAAoD;AAChD,UAAMyG,SAAO,GAAG,KAAKR,aAAL,CAAmBjG,GAAnB,EAAsBC,GAAtB,CAAhB;;AACA,UAAMyG,MAAK,GAAG,KAAKnB,WAAL,CAAiBY,SAAjB,CAA2BM,SAA3B,CAAd;;AAEA,UAAI,KAAKlB,WAAL,CAAiBoB,SAAjB,CAA2BT,KAA3B,EAAkCQ,MAAlC,IAA2Cb,SAA/C,EAA0D;AACtD;AACA,cAAMgB,KAAN;AACH;AACJ,KATsE,CAUvE;;;AACAP,IAAAA,iBAAiB;AACpB,GAxF6B,CA0F9B;;;AACAQ,EAAAA,IAAI,EAAE,KACF,IAAI9G,GAAC,GAAGyB,CAAC,GAAG,CADV,EAEFzB,GAAC,IAAI,IAAIqG,gBAAJ,GAAuBT,gBAF1B,EAGF5F,GAAC,EAHC,EAIJ;AACE,SAAK,IAAIC,GAAC,GAAGyB,CAAC,GAAG,CAAjB,EAAoBzB,GAAC,IAAI,IAAImG,iBAA7B,EAAgDnG,GAAC,EAAjD,EAAqD;AACjD,UAAMwG,SAAO,GAAG,KAAKR,aAAL,CAAmBjG,GAAnB,EAAsBC,GAAtB,CAAhB;;AACA,UAAMyG,MAAK,GAAG,KAAKnB,WAAL,CAAiBY,SAAjB,CAA2BM,SAA3B,CAAd;;AAEA,UAAI,KAAKlB,WAAL,CAAiBoB,SAAjB,CAA2BT,KAA3B,EAAkCQ,MAAlC,IAA2Cb,SAA/C,EAA0D;AACtD;AACA,cAAMiB,IAAN;AACH;AACJ,KATH,CAUE;;;AACAP,IAAAA,gBAAgB;AACnB,GA3G6B,CA6G9B;;;AACA,MAAMQ,mBAAmB,GAAGtF,CAAC,IAAI8E,gBAAgB,GAAGF,gBAAvB,CAA7B,CA9G8B,CA+G9B;;AACA,MAAMW,oBAAoB,GAAGtF,CAAC,IAAI4E,iBAAiB,GAAGF,iBAAxB,CAA9B,CAhH8B,CAiH9B;AAEA;;AACA,MAAIa,MAAM,GAAG,KAAb;;AAEA,MAAInB,cAAJ,EAAoB;AAChB;AACAmB,IAAAA,MAAM,GACFZ,gBAAgB,KAAK,CAArB,IACAD,iBAAiB,KAAK,CADtB,IAEAG,gBAAgB,KAAK,CAFrB,IAGAD,iBAAiB,KAAK,CAJ1B;AAKH,GAPD,MAOO;AACH;AACAW,IAAAA,MAAM,GACFZ,gBAAgB,KAAK,CAArB,IACAD,iBAAiB,KAAK,CADtB,IAEAG,gBAAgB,KAAK,CAFrB,IAGAD,iBAAiB,KAAK,CAJ1B;AAKH;;AAED,MAAIW,MAAJ,EAAY;AACR;AACA,SAAK/D,IAAL,CACImD,gBADJ,EAEID,iBAFJ,EAGIW,mBAHJ,EAIIC,oBAJJ;AAMH;;AAED,MAAI,kCAAc5D,EAAd,CAAJ,EAAuB;AACnBA,IAAAA,EAAE,CAACE,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACH;;AAED,SAAO,IAAP;AACH","sourcesContent":["/* eslint-disable no-labels */\n\nimport Resize from '../modules/resize';\nimport Resize2 from '../modules/resize2';\n\nimport { isNodePattern, throwError } from '../utils/error-checking';\nimport * as constants from '../constants';\n\nfunction rotate90degrees(bitmap, dstBuffer, clockwise) {\n    const dstOffsetStep = clockwise ? -4 : 4;\n    let dstOffset = clockwise ? dstBuffer.length - 4 : 0;\n\n    let tmp;\n    let x;\n    let y;\n    let srcOffset;\n\n    for (x = 0; x < bitmap.width; x++) {\n        for (y = bitmap.height - 1; y >= 0; y--) {\n            srcOffset = (bitmap.width * y + x) << 2;\n            tmp = bitmap.data.readUInt32BE(srcOffset, true);\n            dstBuffer.writeUInt32BE(tmp, dstOffset, true);\n            dstOffset += dstOffsetStep;\n        }\n    }\n}\n\n/**\n * Rotates an image clockwise by a number of degrees rounded to the nearest 90 degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n */\nfunction simpleRotate(deg) {\n    let steps = Math.round(deg / 90) % 4;\n    steps += steps < 0 ? 4 : 0;\n\n    if (steps === 0) return;\n\n    const srcBuffer = this.bitmap.data;\n    const len = srcBuffer.length;\n    const dstBuffer = Buffer.allocUnsafe(len);\n\n    let tmp;\n\n    if (steps === 2) {\n        // Upside-down\n        for (let srcOffset = 0; srcOffset < len; srcOffset += 4) {\n            tmp = srcBuffer.readUInt32BE(srcOffset, true);\n            dstBuffer.writeUInt32BE(tmp, len - srcOffset - 4, true);\n        }\n    } else {\n        // Clockwise or counter-clockwise rotation by 90 degree\n        rotate90degrees(this.bitmap, dstBuffer, steps === 1);\n\n        tmp = this.bitmap.width;\n        this.bitmap.width = this.bitmap.height;\n        this.bitmap.height = tmp;\n    }\n\n    this.bitmap.data = dstBuffer;\n}\n\n/**\n * Rotates an image clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n */\nfunction advancedRotate(deg, mode) {\n    deg %= 360;\n    const rad = (deg * Math.PI) / 180;\n    const cosine = Math.cos(rad);\n    const sine = Math.sin(rad);\n\n    // the final width and height will change if resize == true\n    let w = this.bitmap.width;\n    let h = this.bitmap.height;\n\n    if (mode === true || typeof mode === 'string') {\n        // resize the image to it maximum dimension and blit the existing image\n        // onto the center so that when it is rotated the image is kept in bounds\n\n        // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n        // Plus 1 border pixel to ensure to show all rotated result for some cases.\n        w =\n            Math.ceil(\n                Math.abs(this.bitmap.width * cosine) +\n                    Math.abs(this.bitmap.height * sine)\n            ) + 1;\n        h =\n            Math.ceil(\n                Math.abs(this.bitmap.width * sine) +\n                    Math.abs(this.bitmap.height * cosine)\n            ) + 1;\n        // Ensure destination to have even size to a better result.\n        if (w % 2 !== 0) {\n            w++;\n        }\n\n        if (h % 2 !== 0) {\n            h++;\n        }\n\n        const c = this.cloneQuiet();\n        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n            x,\n            y,\n            idx\n        ) {\n            this.bitmap.data.writeUInt32BE(this._background, idx);\n        });\n\n        const max = Math.max(w, h, this.bitmap.width, this.bitmap.height);\n        this.resize(max, max, mode);\n\n        this.blit(\n            c,\n            this.bitmap.width / 2 - c.bitmap.width / 2,\n            this.bitmap.height / 2 - c.bitmap.height / 2\n        );\n    }\n\n    const bW = this.bitmap.width;\n    const bH = this.bitmap.height;\n    const dstBuffer = Buffer.alloc(this.bitmap.data.length);\n\n    function createTranslationFunction(deltaX, deltaY) {\n        return function(x, y) {\n            return {\n                x: x + deltaX,\n                y: y + deltaY\n            };\n        };\n    }\n\n    const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));\n    const translate2Screen = createTranslationFunction(\n        bW / 2 + 0.5,\n        bH / 2 + 0.5\n    );\n\n    for (let y = 1; y <= bH; y++) {\n        for (let x = 1; x <= bW; x++) {\n            const cartesian = translate2Cartesian(x, y);\n            const source = translate2Screen(\n                cosine * cartesian.x - sine * cartesian.y,\n                cosine * cartesian.y + sine * cartesian.x\n            );\n            const dstIdx = (bW * (y - 1) + x - 1) << 2;\n\n            if (\n                source.x >= 0 &&\n                source.x < bW &&\n                source.y >= 0 &&\n                source.y < bH\n            ) {\n                const srcIdx = ((bW * (source.y | 0) + source.x) | 0) << 2;\n                const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n                dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n            } else {\n                // reset off-image pixels\n                dstBuffer.writeUInt32BE(this._background, dstIdx);\n            }\n        }\n    }\n    this.bitmap.data = dstBuffer;\n\n    if (mode === true || typeof mode === 'string') {\n        // now crop the image to the final size\n        const x = bW / 2 - w / 2;\n        const y = bH / 2 - h / 2;\n        this.crop(x, y, w, h);\n    }\n}\n\n/**\n * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function rotate(deg, mode, cb) {\n    // enable overloading\n    if (typeof mode === 'undefined' || mode === null) {\n        // e.g. image.resize(120);\n        // e.g. image.resize(120, null, cb);\n        // e.g. image.resize(120, undefined, cb);\n        mode = true;\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n        // e.g. image.resize(120, cb);\n        cb = mode;\n        mode = true;\n    }\n\n    if (typeof deg !== 'number') {\n        return throwError.call(this, 'deg must be a number', cb);\n    }\n\n    if (typeof mode !== 'boolean' && typeof mode !== 'string') {\n        return throwError.call(this, 'mode must be a boolean or a string', cb);\n    }\n\n    if (deg % 90 === 0 && Boolean(mode) === false) {\n        simpleRotate.call(this, deg, cb);\n    } else {\n        advancedRotate.call(this, deg, mode, cb);\n    }\n\n    if (isNodePattern(cb)) {\n        cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Flip the image horizontally\n * @param {boolean} horizontal a Boolean, if true the image will be flipped horizontally\n * @param {boolean} vertical a Boolean, if true the image will be flipped vertically\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nfunction flipFn(horizontal, vertical, cb) {\n    if (typeof horizontal !== 'boolean' || typeof vertical !== 'boolean')\n        return throwError.call(\n            this,\n            'horizontal and vertical must be Booleans',\n            cb\n        );\n\n    if (horizontal && vertical) {\n        // shortcut\n        return this.rotate(180, true, cb);\n    }\n\n    const bitmap = Buffer.alloc(this.bitmap.data.length);\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n        x,\n        y,\n        idx\n    ) {\n        const _x = horizontal ? this.bitmap.width - 1 - x : x;\n        const _y = vertical ? this.bitmap.height - 1 - y : y;\n        const _idx = (this.bitmap.width * _y + _x) << 2;\n        const data = this.bitmap.data.readUInt32BE(idx);\n\n        bitmap.writeUInt32BE(data, _idx);\n    });\n\n    this.bitmap.data = Buffer.from(bitmap);\n\n    if (isNodePattern(cb)) {\n        cb.call(this, null, this);\n    }\n\n    return this;\n}\n\nexport const flip = flipFn;\nexport const mirror = flipFn;\n\n/**\n * Resizes the image to a set width and height using a 2-pass bilinear algorithm\n * @param {number} w the width to resize the image to (or Jimp.AUTO)\n * @param {number} h the height to resize the image to (or Jimp.AUTO)\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function resize(w, h, mode, cb) {\n    if (typeof w !== 'number' || typeof h !== 'number') {\n        return throwError.call(this, 'w and h must be numbers', cb);\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n    }\n\n    if (w === constants.AUTO && h === constants.AUTO) {\n        return throwError.call(this, 'w and h cannot both be set to auto', cb);\n    }\n\n    if (w === constants.AUTO) {\n        w = this.bitmap.width * (h / this.bitmap.height);\n    }\n\n    if (h === constants.AUTO) {\n        h = this.bitmap.height * (w / this.bitmap.width);\n    }\n\n    if (w < 0 || h < 0) {\n        return throwError.call(this, 'w and h must be positive numbers', cb);\n    }\n\n    // round inputs\n    w = Math.round(w);\n    h = Math.round(h);\n\n    if (typeof Resize2[mode] === 'function') {\n        const dst = {\n            data: Buffer.alloc(w * h * 4),\n            width: w,\n            height: h\n        };\n        Resize2[mode](this.bitmap, dst);\n        this.bitmap = dst;\n    } else {\n        const image = this;\n        const resize = new Resize(\n            this.bitmap.width,\n            this.bitmap.height,\n            w,\n            h,\n            true,\n            true,\n            buffer => {\n                image.bitmap.data = Buffer.from(buffer);\n                image.bitmap.width = w;\n                image.bitmap.height = h;\n            }\n        );\n        resize.resize(this.bitmap.data);\n    }\n\n    if (isNodePattern(cb)) {\n        cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Scale the image so the given width and height keeping the aspect ratio. Some parts of the image may be clipped.\n * @param {number} w the width to resize the image to\n * @param {number} h the height to resize the image to\n * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function cover(w, h, alignBits, mode, cb) {\n    if (typeof w !== 'number' || typeof h !== 'number') {\n        return throwError.call(this, 'w and h must be numbers', cb);\n    }\n\n    if (\n        alignBits &&\n        typeof alignBits === 'function' &&\n        typeof cb === 'undefined'\n    ) {\n        cb = alignBits;\n        alignBits = null;\n        mode = null;\n    } else if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n    }\n\n    alignBits =\n        alignBits ||\n        constants.HORIZONTAL_ALIGN_CENTER | constants.VERTICAL_ALIGN_MIDDLE;\n    const hbits = alignBits & ((1 << 3) - 1);\n    const vbits = alignBits >> 3;\n\n    // check if more flags than one is in the bit sets\n    if (\n        !(\n            (hbits !== 0 && !(hbits & (hbits - 1))) ||\n            (vbits !== 0 && !(vbits & (vbits - 1)))\n        )\n    )\n        return throwError.call(\n            this,\n            'only use one flag per alignment direction',\n            cb\n        );\n\n    const alignH = hbits >> 1; // 0, 1, 2\n    const alignV = vbits >> 1; // 0, 1, 2\n\n    const f =\n        w / h > this.bitmap.width / this.bitmap.height\n            ? w / this.bitmap.width\n            : h / this.bitmap.height;\n    this.scale(f, mode);\n    this.crop(\n        ((this.bitmap.width - w) / 2) * alignH,\n        ((this.bitmap.height - h) / 2) * alignV,\n        w,\n        h\n    );\n\n    if (isNodePattern(cb)) {\n        cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Scale the image to the given width and height keeping the aspect ratio. Some parts of the image may be letter boxed.\n * @param {number} w the width to resize the image to\n * @param {number} h the height to resize the image to\n * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function contain(w, h, alignBits, mode, cb) {\n    if (typeof w !== 'number' || typeof h !== 'number') {\n        return throwError.call(this, 'w and h must be numbers', cb);\n    }\n\n    // permit any sort of optional parameters combination\n    if (typeof alignBits === 'string') {\n        if (typeof mode === 'function' && typeof cb === 'undefined') cb = mode;\n        mode = alignBits;\n        alignBits = null;\n    }\n\n    if (typeof alignBits === 'function') {\n        if (typeof cb === 'undefined') cb = alignBits;\n        mode = null;\n        alignBits = null;\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n    }\n\n    alignBits =\n        alignBits ||\n        constants.HORIZONTAL_ALIGN_CENTER | constants.VERTICAL_ALIGN_MIDDLE;\n    const hbits = alignBits & ((1 << 3) - 1);\n    const vbits = alignBits >> 3;\n\n    // check if more flags than one is in the bit sets\n    if (\n        !(\n            (hbits !== 0 && !(hbits & (hbits - 1))) ||\n            (vbits !== 0 && !(vbits & (vbits - 1)))\n        )\n    ) {\n        return throwError.call(\n            this,\n            'only use one flag per alignment direction',\n            cb\n        );\n    }\n\n    const alignH = hbits >> 1; // 0, 1, 2\n    const alignV = vbits >> 1; // 0, 1, 2\n\n    const f =\n        w / h > this.bitmap.width / this.bitmap.height\n            ? h / this.bitmap.height\n            : w / this.bitmap.width;\n    const c = this.cloneQuiet().scale(f, mode);\n\n    this.resize(w, h, mode);\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n        x,\n        y,\n        idx\n    ) {\n        this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n    this.blit(\n        c,\n        ((this.bitmap.width - c.bitmap.width) / 2) * alignH,\n        ((this.bitmap.height - c.bitmap.height) / 2) * alignV\n    );\n\n    if (isNodePattern(cb)) {\n        cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Uniformly scales the image by a factor.\n * @param {number} f the factor to scale the image by\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function scale(f, mode, cb) {\n    if (typeof f !== 'number') {\n        return throwError.call(this, 'f must be a number', cb);\n    }\n\n    if (f < 0) {\n        return throwError.call(this, 'f must be a positive number', cb);\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n    }\n\n    const w = this.bitmap.width * f;\n    const h = this.bitmap.height * f;\n    this.resize(w, h, mode);\n\n    if (isNodePattern(cb)) {\n        cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Scale the image to the largest size that fits inside the rectangle that has the given width and height.\n * @param {number} w the width to resize the image to\n * @param {number} h the height to resize the image to\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function scaleToFit(w, h, mode, cb) {\n    if (typeof w !== 'number' || typeof h !== 'number') {\n        return throwError.call(this, 'w and h must be numbers', cb);\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n    }\n\n    const f =\n        w / h > this.bitmap.width / this.bitmap.height\n            ? h / this.bitmap.height\n            : w / this.bitmap.width;\n    this.scale(f, mode);\n\n    if (isNodePattern(cb)) {\n        cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Displaces the image based on the provided displacement map\n * @param {object} map the source Jimp instance\n * @param {number} offset the maximum displacement value\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport function displace(map, offset, cb) {\n    if (typeof map !== 'object' || map.constructor !== this.constructor) {\n        return throwError.call(this, 'The source must be a Jimp image', cb);\n    }\n\n    if (typeof offset !== 'number') {\n        return throwError.call(this, 'factor must be a number', cb);\n    }\n\n    const source = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n        x,\n        y,\n        idx\n    ) {\n        let displacement = (map.bitmap.data[idx] / 256) * offset;\n        displacement = Math.round(displacement);\n\n        const ids = this.getPixelIndex(x + displacement, y);\n        this.bitmap.data[ids] = source.bitmap.data[idx];\n        this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];\n        this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];\n    });\n\n    if (isNodePattern(cb)) {\n        cb.call(this, null, this);\n    }\n\n    return this;\n}\n\n/**\n * Autocrop same color borders from this image\n * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)\n * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)\n * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)\n * @returns {Jimp} this for chaining of methods\n */\nexport function autocrop(...args) {\n    const w = this.bitmap.width;\n    const h = this.bitmap.height;\n    const minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image\n\n    let cb; // callback\n    let tolerance = 0.0002; // percent of color difference tolerance (default value)\n    let cropOnlyFrames = true; // flag to force cropping only if the image has a real \"frame\"\n    // i.e. all 4 sides have some border (default value)\n\n    // parse arguments\n    for (let a = 0, len = args.length; a < len; a++) {\n        if (typeof args[a] === 'number') {\n            // tolerance value passed\n            tolerance = args[a];\n        }\n\n        if (typeof args[a] === 'boolean') {\n            // cropOnlyFrames value passed\n            cropOnlyFrames = args[a];\n        }\n\n        if (typeof args[a] === 'function') {\n            // callback value passed\n            cb = args[a];\n        }\n    }\n\n    /**\n     * All borders must be of the same color as the top left pixel, to be cropped.\n     * It should be possible to crop borders each with a different color,\n     * but since there are many ways for corners to intersect, it would\n     * introduce unnecessary complexity to the algorithm.\n     */\n\n    // scan each side for same color borders\n    const colorTarget = this.getPixelColor(0, 0); // top left pixel color is the target color\n    const rgba1 = this.constructor.intToRGBA(colorTarget);\n\n    // for north and east sides\n    let northPixelsToCrop = 0;\n    let eastPixelsToCrop = 0;\n    let southPixelsToCrop = 0;\n    let westPixelsToCrop = 0;\n\n    // north side (scan rows from north to south)\n    north: for (let y = 0; y < h - minPixelsPerSide; y++) {\n        for (let x = 0; x < w; x++) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break north;\n            }\n        }\n        // this row contains all pixels with the same color: increment this side pixels to crop\n        northPixelsToCrop++;\n    }\n\n    // east side (scan columns from east to west)\n    east: for (let x = 0; x < w - minPixelsPerSide; x++) {\n        for (let y = 0 + northPixelsToCrop; y < h; y++) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break east;\n            }\n        }\n        // this column contains all pixels with the same color: increment this side pixels to crop\n        eastPixelsToCrop++;\n    }\n\n    // south side (scan rows from south to north)\n    south: for (let y = h - 1; y >= northPixelsToCrop + minPixelsPerSide; y--) {\n        for (let x = w - eastPixelsToCrop - 1; x >= 0; x--) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break south;\n            }\n        }\n        // this row contains all pixels with the same color: increment this side pixels to crop\n        southPixelsToCrop++;\n    }\n\n    // west side (scan columns from west to east)\n    west: for (\n        let x = w - 1;\n        x >= 0 + eastPixelsToCrop + minPixelsPerSide;\n        x--\n    ) {\n        for (let y = h - 1; y >= 0 + northPixelsToCrop; y--) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break west;\n            }\n        }\n        // this column contains all pixels with the same color: increment this side pixels to crop\n        westPixelsToCrop++;\n    }\n\n    // safety checks\n    const widthOfPixelsToCrop = w - (westPixelsToCrop + eastPixelsToCrop);\n    // widthOfPixelsToCrop >= 0 ? widthOfPixelsToCrop : 0;\n    const heightOfPixelsToCrop = h - (southPixelsToCrop + northPixelsToCrop);\n    // heightOfPixelsToCrop >= 0 ? heightOfPixelsToCrop : 0;\n\n    // decide if a crop is needed\n    let doCrop = false;\n\n    if (cropOnlyFrames) {\n        // crop image if all sides should be cropped\n        doCrop =\n            eastPixelsToCrop !== 0 &&\n            northPixelsToCrop !== 0 &&\n            westPixelsToCrop !== 0 &&\n            southPixelsToCrop !== 0;\n    } else {\n        // crop image if at least one side should be cropped\n        doCrop =\n            eastPixelsToCrop !== 0 ||\n            northPixelsToCrop !== 0 ||\n            westPixelsToCrop !== 0 ||\n            southPixelsToCrop !== 0;\n    }\n\n    if (doCrop) {\n        // do the real crop\n        this.crop(\n            eastPixelsToCrop,\n            northPixelsToCrop,\n            widthOfPixelsToCrop,\n            heightOfPixelsToCrop\n        );\n    }\n\n    if (isNodePattern(cb)) {\n        cb.call(this, null, this);\n    }\n\n    return this;\n}\n"],"file":"shape.js"}